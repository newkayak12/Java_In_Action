package Chapter_04_스트림_소개;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class Section1 {
    /**
     *          > 스트림이란
     *  스트림을 이용하면 선언형(즉, 데이터를 처리하는 임시 구현 코드)으로 컬렉션이 데이터를 처리할 수 있다.(질의로 표현) 또한, 스트림을 이용하면 멀티
     *  쓰레드를 구현하지 않아도 데이터를 투명하게 병렬로 처리할 수 있다. 또한 filter, sort, map, collect와 같은 고수준 빌딩 블록(hight-level
     *  building block)으로 이루어져 있으므로 특정 쓰레딩 모델에 제한되지 않고 자유롭게 어떤 상황이든 사용할 수 있다. 또한 추가적으로 데이터 처리 과정을
     *  병렬화하면서 쓰레드와 락을 걱정할 필요가 없어진다. (.parallelStream())
     *
     *  자바의 스트림 API 특징을 정리하면
     *  1. 선언형: 더 간결하고 가독성이 좋아진다.
     *  2. 조립할 수 있음 : 유연성이 좋아진다.
     *  3. 병렬화 : 성능이 좋아진다.
     *
     *          > 스트림 시작하기
     *  스트림이란 정확히 뭘까? '스트림이란 데이터 처리 연산을 지원하도록 소스에서 추출된 연속적인 요소(Sequence of Elements)'로 정의할 수 있다.
     *  1. 연속된 요소 : 컬렉션과 마찬가지로 스트림은 특정 요소 형식으로 이뤄진 연속된 값 집합의 인터페이스를 제공한다. 컬렉션은 자료구조이므로 컬렉션에서는
     *  시간, 공간 복잡성과 관련된 요소 저장 및 접근 연산이 주를 이룬다. 반면 스트림은 filter, sorted, map과 같이 표현 계산식이 주를 이룬다.
     *
     *  2. 소스 : 스트림은 컬렉션, 배열, I/O 자원 등의 데이터 제공 소스로부터 데이터를 소비한다. 정렬되니 컬렉션으로 스트림을 생성하면 정렬은 유지된다.
     *
     *  3. 데이터 처리 연산 : 스트림은 함수형 프로그래밍 언어에서 일반적으로 지원하는 연산과 데이터베이스와 비슷한 연산을 지원한다. 예를 들어 filter, map,
     *  reduce, find, match, sort 등으로 데이터를 조작할 수 있다. 스트림 연산은 순차/ 병렬로 실행할 수 있다.
     *
     *  4. 파이프라이닝(PipeLining) : 대부분의 스트림 연산은 스트림 연산끼리 연결해서 커다란 파이프 라인을 구성할 수 있도록 스트림을 반환한다. 또한
     *  laziness, short-circuit과 같은 최적화도 얻을 수 있다.
     *
     *  5. 내부 반복 : 반복자를 통해서 명시적으로 반복하는 컬렉션과 달리 스트림은 내부 반복을 지원한다.
     *
     *  이러한 특징들을 예제로 확인하면
     */
        {
            class Menu{
                private Integer calories;
                private String name;

                public Integer getCalories() {
                    return calories;
                }

                public String getName() {
                    return name;
                }

                public Menu(Integer calories, String name) {
                    this.calories = calories;
                    this.name = name;
                }
            }
            List<Menu> menus = Arrays.asList(new Menu(360, "Pizza"), new Menu(500, "Chicken"),
                    new Menu(1, "Gum"), new Menu(20, "Rice"), new Menu(60, "Water"));

            List<String> threeHighCaloricDishName =  menus.stream()
                    .filter(dish -> dish.getCalories() > 300)
                    .map(Menu::getName)
                    .limit(3)
                    .collect(Collectors.toList());
            System.out.println(threeHighCaloricDishName);
        }
    /**
     *  위의 예제를 보면서 스트림을 이해해보자. menu에 stream() 메소드를 호출해서 스트림을 얻었다. 여기에서 데이터 소스는 Menu 객체이다. 데이터 소스는
     *  연속된 요소를 스트림에 제공한다. 그 다음은 스트림에 filter, map, limit, collect로 이어지는 데이터 처리 연산이다. collect를 제외한 연산은
     *  서로 파이프라인을 형성할 수 있도록 스트림을 반환한다. 파이프라인은 소스에 적용하는 질의와 같다. 마지막으로 collect 연산으로 파이프라인을 처리하여
     *  결과를 반환한다. 마지막의 collect를 호출하기 전까지는 menu에 무엇도 선택되지 않으며, 출력 결과도 없다. 즉, collect가 호출되기 직전까지
     *  메소드 호출이 저장되는 효과가 있다.
     *
     *
     *              > 스트림과 컬렉션
     *  스트림과 컬렉션은 모두 연속된 요소 형식의 값을 저장하는 자료구조의 인터페이스를 제공한다. 여기서 '연속된'이란 표현은 순서와 상관없이 아무 값에나
     *  접근할 수 있다는 것이 아니라 순차적으로 값에 접근한다는 것을 의미한다.
     *
     *  스트림과 컬렉션의 차이점을 살펴보면 '데이터를 언제 계산하는가?'가 컬렉션과 스트림의 큰 차이이다. 컬렉션은 현재 자료구조가 포함하는 모든 값을 메모리에
     *  저장하는 자료구조이다. 즉, 컬렉션의 모든 요소는 컬렉션에 추가되기 전에 계산되어야만 한다. (컬렉션에 요소를 추가하거나 컬렉션에서 요소를 삭제하면 그
     *  때마다 컬렉션의 모든 요소를 메모리에 저장해야하며, 컬렉션에 추가하려는 요소는 미리 계산되어야만 한다.)
     *  반대로 스트림은 이론적으로 요청할 때만 요소를 계산하는 고정된 자료구조이다. (스트림에 요소를 추가하거나 제거할 수는 없다.) 또한 스트림은 사용자가
     *  요청하는 값만 스트림에서 추출한다. 물론 사용자는 이를 알 수는 없다. 결과적으로 스트림은 생선자와 소비자 관계를 형성한다. 또한, 스트림은 게으르게 만들
     *  어지는 컬렉션과 같다고 표현할 수 있다. 즉, 사용자가 데이터를 요청할 때만 값을 계산한다. 반대로 컬렉션은 적극적으로 생산된다. (팔기도 전에 창고를
     *  채우는 것과 같은)
     *
     *
     *              > 스트림의 특징
     *  반복자와 마찬가지로 스트림도 딱 한 번만 탐색할 수 있다. 즉, 탐색된 스트림의 요소는 소비된다. 반복자(iterator)와 마찬가지로 한 번 탐색한 요소를
     *  다시 탐색하려면 초기 데이터 소스에서 새로운 스트림을 만들어야 한다.
     *
     *  두 번쨰는 스트림은 내부 반복을 사용한다. 컬렉션을 반복하려면 사용하려면 사용자가 직접 요소를 반복해야한다.(외부 반복) 그러나 스트림은 (반복을 알아서
     *  처리하고 결과 스트림 값을 어딘가에 저장하는) 내부 반복을 이용한다. 이는 반복 작업을 편리하게 할 수 있게 해준다. 또한 작업을 투명하게 병렬로 처리하거나
     *  더 최적화된 순서로 진행하게 할 수 있다. 실제로 스트림 라이브러리의 내부 반복은 데이터 표현과 하드웨어를 활용한 병렬성 구현을 자동으로 선택한다.
     *
     *              > 스트림의 연산
     *  위의 예시와 같이 스트림의 연산은 filter, map, limit 등 다양하다. 또한 이런 메소드들은 스트림을 계속할 수 있도록 반환 값으로 반환한다.
     *  이렇게 연결할 수 있는 스트림 연산을 중간 연산이라고 하며, collect와 같이 파이프라인을 형성하는 스트림을 닫는 연산을 최종 연산이라고 한다.
     *
     *
     *              > 스트림 이용하기
     *   스트림 이용 과정은 세 가지로 요약할 수 있다.
     *      1. 질의를 수행할 데이터 소스
     *      2. 스트림 파이프라인을 구성한 중간 연산 연결
     *      3. 스트림 파이프라인을 실행하고 결과를 만들 최종 연산
     *   스트림 파이프라인의 개념은 빌더 패턴과 유사하다.
     *
     *
     *
     *
     *
     */
}
