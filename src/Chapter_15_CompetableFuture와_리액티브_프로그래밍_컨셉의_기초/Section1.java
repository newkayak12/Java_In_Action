package Chapter_15_CompetableFuture와_리액티브_프로그래밍_컨셉의_기초;

public class Section1 {
    public static void main(String[] args) {
        /**
         *      병렬성이 아니라 동시성을 필요로하는 상황 즉 조금씩 연관된 작업을 같은 CPU에서 동작하는 것 또는 애플리케이션을 생상성을 극대화할 수 있도록
         *      코어를 놀리지 않는 것이 목표라면, 원격 서비스나 데이터베이스 결과를 기다리는 쓰레드를 블록해서 연산 자원을 낭비하는 것을 막아야한다.
         *
         *      자바는 이런 환경에서 사용할 수 있는 두 가지 주요 도구를 제공한다. Future 인터페이스로 자바 8의 CompletableFuture 구현은 간단하고
         *      효율적인 문제 해결사이다. 여기서 동시성과 병렬성의 차이점이 확실하지 않을 수 있는데 병렬성은 동시간 대 각기 다른 코어에서 작업을 진행하는 것이고
         *      동시성은 코어의 유휴시간 없이 계속해서 각기 다른 작업을 수행하는 것을 일컫는다.
         *
         *
         *
         *              > 15.1 동시성을 구현하는 자바 지원의 진화
         *      자바의 동시 프로그래밍 지원은 변화에 맞춰 진화됐다. 처음에 자바는 Runnable, Thread를 동기화된 클래스와 메소드를 이용해서 잠궜다.
         *      자바 5는 표현력있는 동시성을 지원하는 특히 쓰레드 실행과 태스크 제출을 분리하는 ExecutorService 인터페이스, 높은 수준의 결과 즉,
         *      Runnable, Thread의 변형을 반환하는 Callable<T>, Future<T>, 제네릭 등을 지원했다. ExecutorServices는 Runnable, Callable
         *      을 모두 실행할 수 있다. 이런 기능들 덕분에 멀티코어 CPU에서 쉽게 병렬 프로그래밍을 구현할 수 있게 됐다.
         *      멀티코어 CPU에서 효과적으로 프로그래밍을 실행할 필요성이 커지면서 이후 자바 버전에서는 개선된 동시성 지원이 추가됐다. 자바 7에서는
         *      분할 정복 알고리즘의 포크/조인 구현을 지원하는  java.util.concurrent.RecursiveTask가 추가됐고 자바 8에서는 스트림, 람다 지원에
         *      기반한 병렬 프로세싱이 추가됐다.
         *      자바는 Future을 조합하는 기능을 추가하면서 동시성을 강화했고, 자바 9에서는 분산 비동기 프로그래밍을 명시적으로 지원한다. 이들 API는
         *      매쉬업 애플리케이션 즉, 다양한 웹 서비스를 이용하고 이들 정보를 실시간으로 조합해 사용자에게 제공하거나 추가 웹서비스를 통해 제공하는
         *      종류의 애플리케이션을 개발하는데 필수적인 기초 모델과 툴킷을 제공한다. 이 과정을 리액티브 프로그래밍이라고 부르며 자바9는 pub-sub 프로토콜
         *      (java.util.concurrent.Flow)로 이를 지원한다. CompletableFuture와 java.util.concurrent.Flow의 궁극적인 목표는
         *      가능한한 동시에 실행할 수 있는 독립적인 태스크를 가능하게 만들면서 멀티코어 또는 여러 기기를 통해 제공되는 병렬성을 쉽게 이용하는 것이다.
         *
         *
         *              > 15.1.1 쓰레드와 높은 수준의 추상화
         *      실제로 네 개의 코어를 가진 CPU에서 이론적으로 프로그램을 네 개의 코어에서 병렬로 실행함으로 실행 속도를 네 배까지 향상시킬 수 있다.
         *      예시로 학생들이 제출한 숫자 1,000,000개를 저장할 배열을 처리하는 예제를 살펴보자.
         *
         *         long sum = 0;
         *           for (int i = 0; i < 1_000_000; i++){
         *               sum += stat[i]
         *          }
         *      이는 단일 쓰레드로 하는 작업이고 한나절 걸릴 것이다. 이를 4 개의 쓰레드를 이용하면 아래와 같다.
         *          long sum0 = 0;
         *           for (int i = 0; i < 250_000; i++){
         *                sum0 += stat[i]
         *           }
         *       이를 네 개의 쓰레드로 구성하고 .start()를 한 뒤 .join()으로 완료될 때까지 기다렸다가 sum = sum0 + ... + sum3으로 결과를
         *       받는다. 이를 각 루프로 처리하는 것은 에러가 발생할 수 있는 구조이다. 또한 스트림으로도 가능하다.
         *
         *          sum = Arrays.stream(stats).parallel().sum()
         *
         *       결론적으로 병렬 스트림 반복은 명시적으로 쓰레드를 사용하는 것에 비해 높은 수준의 개념이라는 것을 알 수 있다. 다시 말해 스트림을 이용해
         *       쓰레드 사용 패턴을 추상화할 수 있다. 스트림으로 추상화하는 것은 패턴 디자인을 적용하는 것과 비슷하지만 대신 쓸모 없는 코드가 라이브러리
         *       내부로 구현되면서 복잡성도 줄어든다는 장점이 더해진다. 자바 7의 java.util.concurrent.RecursiveTask 지원 덕분에 포크/조인
         *       쓰레드 추상화로 분할 정복 알고리즘을 병렬화하면서 멀티코어 머신에서 배열의 합을 효율적으로 계산하는 높은 수준의 방식을 제공하는 방법을
         *       설명한다.
         *       추가적 쓰레드 추상화를 보기 전, ExecutorService 개념과 쓰레드 풀을 보자.
         *
         *
         *              > 15.1.2 Executor와 쓰레드풀
         *       자바 5는 Executor 프레임워크와 쓰레드 풀을 통해 쓰레드를 극한으로 사용하는 프로그래머가 테스크 제출과 실행을 분리할 수 있는 기능을
         *       제공했다.
         *
         *              > 쓰레드의 문제
         *       쓰레드는 운영체제 쓰레드에 접근한다. 운영체제 쓰레드를 만들고 종료하려면 (페이지 테이블과 관련된) 비용을 치러야 하며 운영체제 쓰레드 수는
         *       제한되어 있다. 운영체제가 지원하는 쓰레드 수를 초과해서 사용하면 애플리케이션이 크래시될 수 있다. 기존 쓰레드가 실행되는 상태에서
         *       계속 쓰레드를 만드는 상황이 일어나지 않게 해야한다.(폭증)
         *
         *       보통 운영체제와 자바 쓰레드 개수가 하드웨어 쓰레드 수보다 많으므로 일부 운영 체제 쓰레드가 블록/ 자고 있는 상황에서 모든 하드웨어
         *       쓰레드가 코드를 실행하도록 할당된 상황에 놓을 수 있다.
         *
         *
         *              > 쓰레드 풀의 장점
         *       자바 ExecutorService는 태스크를 제출하고 나중에 결과를 수집할 수 있는 인터페이스를 제공한다. 프로그램은 newFixedThreadPool
         *       같은 팩토리 메소드 중 하나를 이용해서 쓰레드풀을 만들어 사용할 수 있다.
         *
         *       ExecutorService newFixedThreadPool(int nThreads)
         *
         *       이 메소드는 워크 쓰레드라고 불리는 nThread를 포함하는 ExecutorService를 만들고 이들을 쓰레드 풀에 저장한다. 쓰레드 풀에서
         *       사용하지 않는 쓰레드로 제출된 태스크를 먼저 온 순서대로 실행한다. 이들 태스크 실행이 종료되면 이들 쓰레드를 풀로 반환한다. 이 방식의
         *       장점은 하드웨어에 맞는 수의 태스크를 유지함과 동시에 수 천개의 태스크를 쓰레드 풀에 아무 오버헤드 없이 제출할 수 있다는 점이다.
         *       큐의 조정, 거부 정책, 태스크 종류에 따른 우선 순위등 다양한 설정을 할 수 있다.
         *       프로그래머는 Task(Runnable, Callable)를 제공하면 이를 쓰레드가 실행한다.
         *
         *
         *              > 쓰레드 풀의 단점
         *       대부분 상황에서 유리하지만 두 가지 사항을 주의해야 한다.
         *
         *          1. k 쓰레드를 가진 쓰레드 풀은 오직 k 만큼의 쓰레드를 동시에 실행할 수 있다. 초과로 제출된 태스크는 큐에 저장되며, 이전에 태스크
         *          중 하나가 종료되기 전까지는 쓰레드에 할당하지 않는다. 불필요하게 많은 쓰레드를 만드는 일을 피할 수 있으므로 보통 이 상황은 아무 문제가
         *          되지 않지만 잠을 자거나 I/O를 기다리거나 네트워크 연결을 기다리는 태스크가 있다면 주의해야한다. I/O를 기다리는 블록 상황에서 이들
         *          태스크가 워크 쓰레드에 할당된 상태를 유지하지만 아무 작업도 하지 않게 된다.
         *          2. 중요한 코드를 실행하는 쓰레드가 죽는 일이 발생하지 않도록 보통 자바 프로그램은 main이 반환하기 전에 모든 쓰레드의 작업이 끝나길
         *          기다린다. 따라서 프로그램을 종료하기 전에 모든 쓰레드 풀을 종료하는 습관을 갖는 것ㅇ리 중요하다. 보통 장기간 실행하는 인터넷 서비스를
         *          관리하도록 오래 실행되는 ExecutorService를 갖는 것은 흔한 일이다.
         *
         *
         *
         *                  > 15.1.3 쓰레드의 다른 추상화 : 중첩되지 않는 메소드 호출
         *       포크/ 조인을 사용한 동시성에서는 한 개의 특별한 속성 즉, 태스크나 쓰레드가 메소드 호출 안에서 시작되면 그 메소드 호출은 반환하지 않고 작업이
         *       끝나기를 기다렸다. 다시 말해 쓰레드 생성과 join()이 한 쌍처럼 중첩된 메소드 호출 내에 추가되었다. 이를 엄격한 포크/조인 이라고 부른다.
         *       시작된 태스크를 내부 호출이 아니라 외부 호출에서 종료하도록 기다리는 좀 더 여유로운 방식의 포크/조인을 사용해도 비교적 안전하다.
         *
         *       이번 장은 메소드 호출에 의해 쓰레드가 생성되고 메소드를 벗어나 계속 실행되는 동시성 형태에 초점을 둔다. 이런 종류, 특히 메소드 호출자에 기능을
         *       제공하도록 메소드가 반환된 후에도 만들어진 태스크 실행이 계속되는 메소드를 비동기 메소드라고 한다. 우선 이들 메소드를 사용할 떄 어떤
         *       위험성이 따르는 지 확인해보자.
         *
         *          1. 쓰레드 실행은 메소드를 호출한 다음의 코드와 동시에 실행되므로 데이터 경쟁 문제를 일으키지 않아야 한다.
         *          2. 기존 실행 중이던 쓰레드가 종료되지 않은 상황에서 자바의 main() 메소드가 반환하면 어떻게 될까? 두 가지 방법이 있는데 어느 하나도
         *          안전하지 않다.
         *              - 애플리케이션을 종료하지 못하고 쓰레드가 끝날 때까지 쓰레드가 실행을 끝낼 때까지 기다린다.
         *              - 애플리케이션 종료를 방해하는 쓰레드를 강제 종료 시키고 애플리케이션을 종료한다.
         *           첫 번쨰 방법에서는 잊고서 종료 못한 쓰레드에 의해 애플리케이션이 크래쉬 될 수 있다. 또한 다른 문제로 디스크 쓰기 I/O 작업을 시도하는
         *           일련의 작업을 중단했을 때 이로 인해 외부 데이터의 일관성이 파괴될 수 있다. 이들 문제를 피하려면 애플리케이션에서 만든 모든 쓰레드를
         *           추적하고 애플리케이션을 종료하기 전에 쓰레드 풀을 포함한 모든 쓰레드를 종료하는 것이 좋다.
         *
         *           자바 쓰레드는 setDaemon() 메소드를 이용해 데몬 또는 비데몬으로 구분시킬 수 있다. 데몬 쓰레드는 애플리케이션이 종료될 때 강제로
         *           종료되므로 디스크의 데이터 일관성을 파괴하지 않는 동작을 수행할 때 유용하게 활용할 수 있는 반면, main() 메소드는 모든 비데몬
         *           쓰레드가 종료될 때까지 프로그램을 종료하지 않고 기다린다.
         *
         *
         *                      > 15.1.4 쓰레드에 바라는 바
         *      일반적으로 모든 하드웨어 쓰레드를 이용해 병령성의 장점을 극대화하도록 프로그램 구조를 만드는 것 즉, 프로그램을 작은 태스크 단위로 구조화하는
         *      것이 목표이다. (하지만 태스크 변환 비용을 고려해서 너무 작은 크기는 아니어야 한다.)
         *
         *
         *
         *                      > 15.2 동기 API, 비동기 API
         *      루프 기반 계산을 제외한 다른 상황에서도 병렬성이 유용할 수 있다. 아래와 같은 시그니쳐를 갖는 f,g 메소드의 호출을 합하는 예제를 살펴보자.
         *
         *          int f ( int x );
         *          int g ( int x );
         *
         *      참고로 이들 메소드는 물리적 결과를 반환하므로 동기(API)라고 부른다. 다음처럼 두 메소드를 호출하고 합계를 출력하는 코드가 있다.
         *
         *          int y = f ( x );
         *          int z = g ( x );
         *          System.out.println( y + z );
         *
         *      f,g를 실행하는데 오랜 시간이 걸린다고 할 떄 f, g의 작업을 컴파일러가 완전하게 이해하기 어려우므로 보통 자바 컴파일러는 코드 최적화와
         *      관련한 아무 작업도 수행하지 않을 수 있다. f,g가 서로 상호작용하지 않는다는 사실을 알고 있거나 상호작용을 전혀 신경쓰지 않는다면 f, g를
         *      별도의 코어로 실행함으로써 f, g 중 오래 걸리는 시간으로 합계를 구하는 시간을 단축할 수 있다. 별도의 쓰레드로  f, g를 실행해 구현할 수
         *      있지만 코드가 복잡해진다.
         *
         *          int x = 1337;
         *          Result result = new Result();
         *
         *          Thread t1 = new Thread( () -> {result.left = f(x); } );
         *          Thread t2 = new Thread( () -> {result.right = g(x); } );
         *          t1.start();
         *          t2.start();
         *          t1.join();
         *          t2.join();
         *          System.out.println(result.left + result.right
         *
         *          private static class Result {
         *              private int left;
         *              private int right;
         *          }
         *
         *      쓰레드 풀을 사용해도 복잡하다.
         *
         *           int x = 1337;
         *
         *           ExecutorService = executorService = Executors.newFixedThreadPool(2);
         *           Future<Integer> y = executorService.submit(() -> f(x));
         *           Future<Integer> z = executorService.submit(() -> g(x));
         *           System.out.println(y.get() + z.get());
         *
         *           executorService.shutdown();
         *
         *
         *     이러한 문제의 해결은 비동기 API라는 기능으로 API를 바꿔서 해결할 수 있다.
         *     첫 번쨰 방법인 자바의 Future를 이용하면 이 문제를 조금 개선할 수 있다. 자바 5에서 소개된 Future은 CompletableFuture로
         *     이들을 조합할 수 있게 되면서 기능이 품부해졌다. 두 번쨰 방법은 publish - subsribe 모델에 기반한 java.concurrent.Flow 인터페이스를
         *     이용하는 방법이다.
         *
         *                          > 15.2.1 Future 형식 APi
         *      대안을 사용하면 f, g 시그니처가
         *
         *              Future<Integer> f (int x);
         *              Future<Integer> g (int x);
         *
         *              Future<Integer> y = f(x)
         *              Future<Integer> z = g(x)
         *              System.out.println(y.get() + z.get());
         *
         *      메소드 f,g는 원래 바디를 평가하는 태스크를 포함하는 Future를 반환한다. get을 사용해서 Future가 완료되어 결과가 합쳐지기를 기다린다.
         *      f, g 중 하나에만 Future을 적용할 수 있지만 그러지 않는다.
         *
         *          1. 다른 상황에서도 g에도 Future가 필요할 수 있으므로 통일하는 것이 좋다.
         *          2. 병렬 하드워ㅔ어로 실행속도를 극대화려면 여러 작은, 합리적인 크기의 태스크로 나누는 것이 좋다.
         *
         *
         *                          > 15.2.2 리액티브 형식 API (#ReactiveTest)
         *
         *     두 번째 대안에서 핵심은 f, g의 시그니처를 바꿔서 콜백 형식의 프로그래밍을 이용하는 것이다.
         *
         *              void f(int x, IntConsumer dealWithResult);
         *
         *     f에 추가 인수로 콜백을 전달해서 f의 바디에서는 return 문으로 결과를 반환하는 것이 아니라 결과가 준비되면 이를 람다로 호출하는 태스크를 만드는
         *     방법이다. 다시 말해 f는 바디를 실행하면서 태스크를 만든 다음 즉시 반환하므로 코드 형식이 아래와 같이 바뀐다.
         *
         *
         *              public class CallbackStyleExample {
         *                  public static void main(String[] args) {
         *                      int x = 1337;
         *                      f(x, (int y) -> {
         *                          result.left = y;
         *                          System.out.println(result.left + result.right));
         *                      });
         *
         *                      g(x, (int z) -> {
         *                          result.right = z;
         *                          System.out.println((result.left + result.right));
         *                      }
         *                  }
         *              }
         *
         *     하지만 결과가 달라졌다. f, g의 호출 합계를 정확하게 출력하지 않고 상화엥 따라 먼저 계산된 결과를 출력한다. 락을 사용하지 않으므로 값을
         *     두 번 출력할 수 있을 뿐더러 println 안의 두 피연산자가 println이 실행되기 전에 업데이트 될 수 있다.
         *
         *          1. if-then-else로 적절한 락을 이용해 두 콜백이 모두 호출되었는지 확인한 다음 println을 호출해 원하는 기능을 수행할 수 있다.
         *          2. 리액티브 형식의 API는 보통 한 결과가 아니라 일련의 이벤트에 반응하도록 설계되었으므로 Future을 사용하는 것이 더 적절하다.
         *
         *    리액티브 형식의 프로그래밍으로 메소드 f, g는 dealWithResult 콜백을 여러번 호출할 수 있다. 원래의 f,g 함수는 오직 한 번만 return
         *    하도록 되어있다. 마찬가지로 Future도 한 번만 완료되며 그 결과는 get()으로 얻을 수 있다. 리액티브 형식의  비동기  API는 자연스럽게
         *    일련의 값(나중에 스트림으로 연결)을, Future 형식의 일회성의 값을 처리하는 데 적합하다.
         *
         *    API는 명시적으로 쓰레드를 처리하는 코드에 비해 사용 코드를 더 단순하게 만들어주며 높은 수준의 구조를 유지할 수 있게 도와준다. 또한 (a)
         *    계산이 오래 걸리는 메소드, (b) 네트워크나 사람의 입력을 기다리는 메소드에 이들 API를 잘 활용하면 애플리케이션의 효율성이 크게 향상된다.
         *    (b)의 상황에서는 리소스를 낭비하지 않고 효율적으로 하단의 시스템을 활용할 수 있다는 장점을 추가로 제공한다.
         *
         *
         *
         *              > 15.2.3 기타 블로킹 동작은 해로운 것으로 간주
         *    사람과 상호작용하거나 어떤 일이 일정 속도로 제한되어 일어나는 상황의 애플리케이션을 만들 때 자연스럽게 sleep()을 사용할 수 있다. 하지만
         *    쓰레드는 잠들어도 여전히 자원을 점유한다. 쓰레드를 단지 몇 개 사용한다면 큰 문제가 아니겠지만 쓰레드가 많아지고 대부분이 잠을 잔다면
         *    문제가 심각해진다.
         *
         *    쓰레드 풀에서 잠을 자는 태스크는 다른 태스크가 시작되지 못하게 막으므로 자원을 소비한다. 물론 쓰레드 풀에서 잠자는 쓰레드만 실행을 막는 것은
         *    아니다. 모든 블록 동작도 마찬가지이다. 블록 동작은 다른 태스크가 어떤 동작을 완료하기를 기다리는 동작과 외부 상호 작용을 기다리는 동작,
         *    두 가지로 구분할 수 있다.
         *
         *    이 상황에서 무엇을 할 수 있을까? 이상적으로는 절대 태스크에서 기다리는 일을 만들지 말거나 코드에서 예외를 일으키는 식으로 이를 처리할 수 있다.
         *    태스크를 앞과 뒤 두 부분으로 나누고 블록되지 않을 때만 뒷 부분을 자바가 스케쥴링하도록 요청할 수 있다.
         *
         *
         *          #exam_15_2_3.ScheduledExecutorServiceExample.java
         *
         *
         *    두 태스크(A,B) 모두 쓰레드 풀에서 실행된다고 가정하자. A는 쓰레드 풀 큐에 추가되며 나중에 차례가 되면 실행된다. 하지만 코드가 실행되면
         *    워커 쓰레드를 점유한 상태에서 10초를 그냥 허비한다. 그리고 깨어나서 work2를 실행하고 작업을 종료하고 워커 쓰레드를 해제하낟.
         *
         *    반면에 B는 work1을 실행하고 잔다. 하지만 work2가 10초 뒤 실행될 수 있도록 큐에 추가한다. 물론 A,B 모두 같은 작업을 한다. 그러나
         *    A는 자는 동안 쓰레드를 점유하는 반면 B는 다른 작업이 실행 될 수 있도록 허용한다. 태스크를 만들 때는 이런 특징을 잘 활용해야한다. 태스크가
         *    실행되면 귀중한 자원을 점유하므로 태스크가 끝나서 자원을 해제하기 전까지 태스크를 계속 실행해야 한다. 태스크를 블록하는 것보다는 다음 작업을
         *    태스크로 제출하고 현재 태스크는 종료하는 것이 바람직하다.
         *
         *    가능하다면 I/O 작업에서도 이 원칙을 적용하는 것이 좋다. 고전적으로 읽기 작업을 기다리는 것이 아니라 블록하지 않는 '읽기 시작' 메소드를 호출하고
         *    읽기 작업이 끝나면 이를 처리할 다음 태스크를 런타임 라이브러리에 스케쥴하도록 요청하고 종료한다.
         *
         *    이런 디자인 패턴을 따르려면 읽기 어려운 코드가 많아 지는 것처럼 보일 수 있다. 하지만 자바 CompletableFuture는 future에 get()을 이용해
         *    명시적으로 블록하지 않고 콤비네이터를 사용함으로 이런 형식의 코드를 런타임 라이브러리 내에 추상화한다.
         *
         *    마지막으로 쓰레드의 제한이 없고 저렴하다면 A, B는 사실상 같다. 하지만 쓰레드에는 제한이 있고 저렴하지 않으므로 잠을 자거나 블록해야 하는
         *    여러 태스크가 있을 때 가능하면 B가 낫다.
         *
         *
         *
         *                  > 15.2.4 현실성 확인
         *    새로운 시스템을 설계할 때 시스템을 많은 작은 동시 실행되는 태스크로 설계해서 블록할 수 있는 모든 동작을 비동기 호출로 구현한다면 병렬 하드웨어를
         *    최대한 활용할 수 있다. 하지만 현실적으로 '모든 것을 비동기'라는 설계 원칙을 어겨야한다. 이를 구현하는 것은 쉽지 않다.
         *
         *
         *                  > 15.2.5 비동기 API에서 예외는?
         *    Future나 리액티브 형식의 비동기 API에서 호출된 메소드의 실제 바디는 별도의 쓰레드에서 호출되며 이때 발생하는 어떤 에러는 이미 호출자의 실행
         *    범위와는 관계가 없는 상황이 된다. 예상치못한 일이 일어나면 예외를 발생시켜 다른 동작이 실행되어야 한다. 어떻게 구현할까? Future를 구현한
         *    CompletableFuture에서는 런타임 get() 메소드에 예외를 처리할 수 있는 기능을 제공하여 예외에서 회복할 수 있도록 exceptionally()
         *    같은 메소드를 제공한다.
         *
         *    리액티브 형식의 비동기 API에서는 return 대신 기존 콜백에 호출되므로 예외가 발생했을 때 실행될 추가 콜백을 만들어 인터페이스를 바꿔야한다.
         *    아래 예제처럼 리액티브 API에 여러 콜백을 포함해야한다.
         *
         *          void f(int x, Consumer<Integer> dealWithResult, Consumer<Throwable> dealWithException);
         *
         *    f의 바디는 아래와 같은 것을 수행할 수 있다. dealWithException(e);
         *
         *    롤백이 여러 개면 이를 따로 제공하는 것보다 한 객체로 이 메소드를 감싸는 것이 좋다. 예를 들어 자바 flow API 에서는 여러 콜백을 한 객체로 감싼다.
         *
         *          void onComplete()
         *          void onError(Throwable throwable)
         *          void onNext(T item)
         *
         *    값이 있을 때(onNext), 도중 에러가 발생했을 때(onError), 값을 다 소진했거나 에러가 발생해서 더 이상 처리할 데이터가 없을 때(onComplete)
         *    각각의 콜백이 호출된다. 이전의 f에 이를 적용하면 아래와 같이 시그니처가 바뀐다.
         *
         *          void f(int x, Subscriber<Integer> s);
         *
         *    f의 바디는 다음처럼 Throwable을 가리키는 t로 예외가 일어났음을 가리킨다.
         *
         *          s.onError(t);
         *
         *    여러 콜백을 포함하는 API를 파일이나 키보드 장치에서 숫자를 읽는 작업과 비교해보자. 이들 장치가 수동적인 데이터 구조체가 아니라 결과에 대해서
         *    일련의 데이터를 만들어 처리하고 처리가 끝나면 알림을 만든다. 보통 이런 종류의 호출을 메시지 또는 이벤트라고 부른다. 이런 이벤트를 API의
         *    일부로 보자면 API는 이벤트의 순서(채널 프로토콜(Channel protocol)이라고 불리는)에는 전혀 개의치 않는다. 실제 부속 문서에서는 "onComplete"
         *    이벤트 다음에는 "아무 이벤트도 일어나지 않음" 같은 구문을 사용해서 프로토콜을 정의한다.
         *
         *
         *                  > 15.3 박스와 채널 모델
         *
         *     동시성 모델을 가장 잘 설계하고 개념화 하려면 기법이 필요하다. 바로 박스와 채널 모델(box and channel model)이다. 이전 예시인
         *     f(x) + g(x)의 계산을 일반화해서 정수와 관련된 간단한 상황이 있다고 가정하자. f, g를 호출하거나 p 함수에 인수 x를 이용해서 호출하고 그
         *     결과를 q1, q2로 전달해서 다시 이 호출의 결과로 함수 r을 호출한 다음에 결과를 출력한다.
         *
         *                           q1
         *              x -->  p  〈      〉 r ->
         *                           q2
         *
         *     int t = p(x);
         *     System.out.println( r(q1(t), q2(t)) );
         *
         *     이 예제는 병렬성과 거리가 멀다.
         *
         *     int t = p(x);
         *     Future<Integer> a1 = executorService.submit(() -> q1(t));
         *     Future<Integer> a2 = executorService.submit(() -> q2(t));
         *     System.out.println( r(a1.get(), a2.get()) );
         *
         *     시스템에서 많은 작업이 동시에 실행되고 있지 않다면 이 방법도 동작할 수 있다. 하지만 시스템이 커지고 각각의 많은 박스와 채널 다이어그램이
         *     등장하고 각각의 박스는 내부적으로 자신만의 박스와 채널을 사용한다면 문제가 달라진다. 많은 태스크가  get()을 호출해 Future가
         *     끝나기까지 기다릴 수 있다. 결과적으로 하드웨어는 병렬성을 제대로 활용하지 못하거나 심지어 데드락에 걸릴 수도 있다. 또한 이런 대규모 시스템
         *     구조가 얼마나 많은 수의 get()을 감당할 수 있을지 예측하기 어렵다. 자바 8에서는 CompletableFuture와 콤비네이터(combinators)를
         *     이용해 문제를 해결한다. 두 Function이 있을 때 compose(), andThen() 등을 이용해 다른 Function을 얻을 수 있다. 그렇지만
         *     박스와 채널 다이어그램은 콤비네이터로도 구현할 수 있다. 자바 Function p, q1, q2, BiFunction r로 구현할 수 있다.
         *
         *     마지막으로 박스와 채널 모델을 이용해서 생각과 코드를 구조화 할 수 있다. 박스와 채널 모델로 대규모 시스템 구현의 추상화 수준을 높일 수 있다.
         *     박스로 원하는 연산을 표현하면 계산을 손으로 코딩한 결과보다 더 효율적일 것이다. 콤비네이터는 수학적 함수뿐 아니라 Future와 리액티브 스트림
         *     데이터에도 적용할 수 있다.
         *
         *
         *                  > 15.4 CompletableFuture와 콤비네이터를 이용한 동시성
         *     동시 코딩 작업을 Future 인터페이스로 생각하도록 유도한다는 점이 Future 인터페이스의 문제이다. 하지만 역사적으로 주어진 연산으로 Future
         *     을 만들고 이를 실행하고, 종료되길 기다리는 등 Future는 FutureTask 구현을 뛰어 넘는 몇 가지 동작을 제공했다. 이후 버전의 자바에서는
         *     RecursiveTask 같은 더 구조화된 자원을 제공한다.
         *
         *     자바 8에서는 Future 인터페이스의 구현인 CompletableFuture을 이용해서 Future를 조합할 수 있는 기능을 추가했다. 그럼 ComposableFuture
         *     가 아니라 CompletableFuture라고 부르는 이유는 뭘까? 일반적으로 Future는 실행해서 get()으로 결과를 얻을 수 있는 Callable로 만들어진다.
         *     하지만 CompletableFuture는 실행할 코드 없이 Future를 만들 수 있도록 허용하며 complete() 메소드를 이용해서 나중에 어떤 값을 이용해
         *     다른 쓰레드가 이를 완료할 수 있고 get()으로 값을 얻을 수 있도록 허용한다.
         *
         *                  exam_15_4.CFComplete.java
         *
         *      위 예시는 get까지 기다리므로 자원을 낭비할 수 있다. 그러나 CompletableFuture<T>에 thenCombine 메소드를 사용함으로 두 연산 결과를
         *      더 효율적으로 도출할 수 있다. thenCombine 메소드는 다음과 같은 시그니처를 갖고 있다.
         *
         *                  CompletableFuture<V> thenCombine(CompletableFuture<U> other, BiFunction<T,U,V> fn);
         *
         *      이 메소드는 두 개의 CompletableFuture 값(T, U 결과 형식)을 받아 한 개의 새 값을 만든다. 처음 두 작업이 끝나면 두 결과 모두에
         *      fn을 적용하고 블록하지 않은 상태로 결과 Future을 반환한다.
         *
         *                   exam_15_4.CFCombine.java
         *
         *      thenCombine 행이 핵심이다. Future a와 Future b의 결과를 알지 못한 상태에서 thenCombine은 두 연산이 끝났을 때 쓰레드 풀에서
         *      실행된 연산을 만든다. 결과를 추가하는 세 번쨰 연산은 다른 두 작업이 끝날 때까지는 쓰레드에서 실행되지 않는다. (먼저 시작해서 블록되지 않는다.)
         *      따라서 기존에 발생했던 블로킹 문제가 어디에서도 일어나지 않는다.
         *
         *      상황에 따라서는 이전의 방식과 같이 get()을 기다리는 쓰레드가 큰 문제가 되지 않을 수 있다. 하지만 어떤 상황에서는 많은 수의 Future를
         *      사용해야한다. 이런 상황에서는 CompletableFuture와 콤비네이터를 이용해서 get()에서 블록하지 않을 수 있고 그렇게 함으로 병렬 실행의
         *      효율성은 높이고 데드락은 피하는 최상의 해결책을 구현할 수 있다.
         *
         *
         *      TODO <FLOW 어떻게 구현했는지 찾아보기>
         *
         *                      > 15.5 발행-구독(pub-sub) 그리고 리액티브 프로그래밍 **
         *      Future와 CompletableFuture은 독립적 실행과 병렬성이라는 정식적 모델에 기반한다. 연산이 끝나면 get()으로 Future의 결과를 얻을
         *      수 있다. 따라서 Future는 한 번만 실행해 결과를 제공한다.
         *
         *      반면 리액티브 프로그래밍은 시간이 흐르면서 여러 Future 같은 객체를 통해 여러 결과를 제공한다. 먼저 온도계 객체를 에로 보자. 이 객체는
         *      매 초마다 온도 값을 반복적으로 제공한다. 또 다른 예로 웹 서버 컴포넌트 응답을 기다리는 리스너 객체를 생각할 수 있다. 이 객체는
         *      네트워크에 HTTP 요청이 발생하길 기다렸다가 이후에 결과 데이터를 생산한다. 그리고 다른 코드에서 온도 값 또는 네트워크 결과를 처리한다.
         *      그리고 온도계와 리스너 객체는 다음 결과를 처리할 수 있도록 온도 결과나 다른 네트워크 요청을 기다린다.
         *
         *      눈여겨봐야 할 두 가지 사실이 있다. 두 예제에서 Future 같은 동작이 모두 사용되었지만 한 예제에서는 한 번의 결과가 아니라 여러 번의 결과가
         *      필요하다. 두 번쨰 예제에서 눈여겨 봐야할 것은 모든 결과가 똑같이 중요한 반면 온도계 예제에서는 대부분 사람에게 가장 최근의 온도만 중요하다.
         *      이런 종류의 프로그래밍을 리액티브라고 부르는 이유가 뭘까? 이는 낮은 온도를 감지했을 때 반응 하는 부분이 존재하기 때문이다.
         *
         *      여기서 프로그램이 스트림 모델에 잘 맞는 상황이라면 가장 좋은 구현이 될 수 있다. 하지만 보통 리액티브 프로그래밍 패러다임은 비싼 편이다.
         *      주어진 자바 스트림은 한 번의 단말 동작으로 소비될 수 있다.  스트림 패러다임은 두 개의 파이프라인으로 값을 분리하기 어려우며 분리된 스트림
         *      에서 값을 합치기도 어렵다. 스트림은 파이프라인 처리 기법에 알맞다.
         *
         *      자바 9에서는 java.util.concurrent.Flow의 인터페이스에 발행-구독 모델을 이용해서 리액티브 프로그래밍을 제공한다.
         *
         *          1. 구독자가 구독할 수 있는 발행자
         *          2. 이 연결을 구독이라고 한다.
         *          3. 이 연결을 이용해서 메시지(이벤트)를 전송한다.
         *
         *     두 정보 소스로부터 발생하는 이벤트를 합쳐서 다른 구독자가 볼 수 있도록 발행하는 예를 통해서 pub-sub 특징을 확인할 수 있다. 사실 이 기능은
         *     수식을 포함하는 스프레드 시트에서 흔히 제공하는 동작이다. "=C1+C2" 라는 C3를 만든다. C1, C2 중 하나가 변경되면 새로운 값이 반영된다.
         *
         *              exam_15_5_1.SimpleCellExam.java
         *
         *     결과를 통해서 C1의 값이 갱신되면 C3도 갱신한다는 것을 알 수 있다. 발행자-구독자 상호작용의 멋진 점은 발행자 구독자의 그래프를 설정할 수 있다.
         *
         *               exam_15_5_1.SimpleCellExam.java /********* 아래 부분
         *
         *          {
         *                  데이터가 발행자(생산자)에서 구독자(소비자)로 흐름에 착안해 개발자는 이를 업스트림/ 다운스트림이라고 부른다.
         *                  위 예제에서 데이터 newValue는 업스트림 onNext() 메소드로 전달되고 notifyAllSubscribers() 호출을 통해
         *                  다운스트림 onNext() 호출로 전달된다.
         *          }
         *
         *
         *     우선, 실제로 flow를 이용하려면 onNext() 이벤트 외에 onError, onComplete와 같은 메소드를 통해 데이터 흐름에서 예외가 발생하거나
         *     데이터 흐름이 종료되었음을 알 수 있어야한다. 자바 9 플로 API의 Subscriber에서는 실제 onError, onComplete을 지원한다. 기존의
         *     옵저버 패턴에 비해 새로워진 API 프로토콜이 위와 같은 메소드 덕분에 강력해졌다.
         *     쓰레드 활용에서 onError, onComplete은 필수이다. flow를 사용할 때 빠른 속도로 발생하는 이벤트를 아무 문제 없이 처리할 수 있을까?
         *     마찬가지로 모든 SMS 메시지를 폰으로 제공하는 발행자에 가입하는 상황을 생각해보자. 처음에 약간의 SMS 메시지가 있는 새폰에서는 가입이 잘
         *     동작할 수 있지만 매 초마다 수천 개의 메시지가 onNext()로 전달된다면 어떻게 될까? 이런 상황을 압력이라고 한다.
         *     이런 상황에서는 출구로 추가될 이벤트의 수를 제한하는 역압력이 필요하다. 자바 9 플로 API 에서는 발생자가 무한의 속도로 아이템을 방출하는 대신
         *     요청을 했을 때만 다음 아이템을 보내도록 하는 메소드(Subscription 인터페이스에 포함)를 제공한다. (push가 아닌 pull 모델)
         *
         *
         *
         *                      > 15.5.2 역압력
         *     Subscriber 객체(onNext, onError, onComplete 메소드를 포함)를 어떻게 Publisher에 게 전달해 발행자가 필요한 메소드를 호출할 수
         *     있는지 확인했다. 이 객체는 Publisher에서 Subscriber로 정보를 전달한다. 정보의 흐름 속도를 역압력(흐름 제어)으로 제어 즉, Subscriber
         *     에서 Publisher로 정보를 요청해야할 필요가 있을 수 있다. Publisher는 여러 Subscriber를 가지고 있으므로 역압력 요청이 한 연결에만
         *     영향을 미치는 것이 문제가 될 수 있다. 이러한 문제를 자바 9 플로 API의 Subscriber 인터페이스는 네 번쨰 메소드를 포함한다.
         *
         *              void onSubscribe(Subscription subscription);
         *
         *      Publisher와 Subscriber 사이에 채널이 연결되면 첫 이벤트로 이 메소드가 호출된다.
         *
         *
         *              interface Subscription {
         *                  void cancel{};
         *                  void request (long n);
         *              }
         *
         *       콜백을 통한 역방향 소통에 대해서 주목하자. Publisher는 Subscription 객체를 만들어 Subscriber로 전달하면 Subscriber는 이를
         *       이용해서 Publisher로 정보를 보낼 수 있다.
         *
         *
         *                      > 15.5.3 실제 역압력의 간단한 형태
         *       한 번의 한 개의 이벤트를 처리하도록 발행-구독 연결을 구성하려면 아래의 작업이 필요하다.
         *
         *              1. Subscriber가 OnSubscribe로 전달된 Subscription 객체를 Subscription 같은 필드에 로컬로 저장한다.
         *              2. Subscriber가 수많은 이벤트를 받지 않도록 onSubscribe, onNext, onError의 마지막 동작에 channel.request(1)
         *              을 추가해서 오직 한 이벤트만 요청한다.
         *              3. 요청을 보낸 채널에면 onNext, onError 이벤트를 보내도록 Publisher의 notifyAllSubscribers 코드를 바꾼다.
         *              (보통 여러 Subscriber가 자신만의 속도를 유지할 수 있도록 Publisher는 새 Subscription을 만들어 각 Subscriber와
         *              연결한다.)
         *
         *        구현이 간단해 보이지만 역압력을 구현하려면 여러가지 장단점을 생각해야한다.
         *
         *              1. 여러 Subscriber가 있을 때 이벤트를 가장 느린 속도로 보낼 것인가 아니면 각 Subscriber에게 보내지 않은 데이터를
         *              저장한 별도의 큐를 가질 것인가.
         *              2. 큐가 비대해지면 어떻게 할 것인가.
         *              3. Subscriber가 준비가 안됐다면 큐의 데이터를 폐기할 것인가
         *
         *       이는 데이터 성격에 달라진다. 온도 데이터가 증발하는 것은 그럴 수 있지만 은행 계좌의 돈이 사라지는 것은 큰 일이다. 당김 기반의 리액티브
         *       역압력이라는 개념이 있는데 이 기법에서는 Subscriber가 Publisher로부터 요청을 당긴다는 의미에서 리액티브 당김 기반이라고 불린다.
         *       결과적으로 이런 방식으로 역압력을 구현할 수 있다.
         *
         *
         *                  > 15.6 리액티브 시스템 vs 리액티브 프로그래밍
         *       리액티브 시스템, 리액티브 프로그래밍 상당히 다른 의미를 가지고 있다. 리액티브 시스템은 런타임 환경이 변화에 대응하도록 전체 아키텍쳐가 설
         *       계된 프로그램을 가리킨다. 반응성, 회복성, 탄력성을 가져야한다.
         *
         *       반응성은 리액티브 시스템이 큰 작업을 처리하느라 간단한 질의의 응답을 지연하지 않고 실시간으로 입력에 반응하는 것을 의미한다. 회복성은
         *       한 컴포넌트의 실패로 전체 프로그램이 실패하지 않음을 의미한다. 네트워크가 고장났어도 이와 관계 없는 질의에는 문제가 없어야 하며, 반응이
         *       없는 컴포넌트를 향한 질의가 있다면 다른 대안을 찾아야한다. 탄력성은 시스템이 자신의 작업 부하에 맞게 적응하며 작업을 효율적으로 처리함을
         *       의미한다.
         *
         *       여러 가지 방법으로 이런 속성을 구현할 수 있지만 java.util.concurrent.Flow 관련된 자바 인터페이스에서 제공하는 리액티브 프로그래밍
         *       형식을 이용하는 것도 주요 방법 중 하나이다. 이들 인터페이스 설계는 Reactive manifesto 의 네 번쨰이자 마지막 속성인 메시지 주도
         *       (message-driven) 속성을 반영한다. 메시지 주도 시스템은 박스와 채널 모델이 기반한 내부 API를 가지고 있는데 여기서 컴포넌트는 처리할
         *       입력을 기다리고 결과를 다른 컴포넌트로 보내면서 시스템이 반응한다.
         *
         *
         */

    }
}
