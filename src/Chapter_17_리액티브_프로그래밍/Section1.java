package Chapter_17_리액티브_프로그래밍;

public class Section1 {
    public static void main(String[] args) {
    /**
     *              > 리액티브 프로그래밍
     *
     *  리액티브 프로그래밍은 아래의 세 가지 이유로 최근 대두되었다
     *
     *      1. 빅데이터 : 보통 빅데이터는 패타바이트 단위로 구성되며 매일 증가한다.
     *      2. 다양한 환경 : 모바일 디바이스에서 수천 개의 멀티 코어 프로세서로 실행되는 클라우드 기반 클러스터에 이르기까지 다양한 환경에 애플리케이션이
     *      배포된다.
     *      3. 사용 패턴 : 사용자는 1년 내내 항상 서비스를 이용할 수 있으며 밀리초 단위의 응답 시간을 기대한다.
     *
     *  지금까지의 아키텍쳐로는 이들을 만족시키기 어렵다.
     *
     *  리액티브 프로그래밍에서는 다양한 시스템과 소스에서 들어오는 데이터 항목 스트림을 비동기적으로 처리하고 합쳐서 이런 문제를 해결하낟. 실제로 이런 패러다임에
     *  맞게 설계된 애플리케이션은 발생한 데이터 항목을 바로 처리함으로써 사용자에게 높은 응답성을 제공한다. 게다가 한 개의 컴포넌트나 애플리케이션뿐만 아니라
     *  전체의 리액티브 시스템을 구성하는 여러 컴포넌트를 조절하는 데도 리액티브 기법을 사용한다. 이런 방식으로 구성된 시스템에서는 고장, 정전 같은 상태에
     *  대처할 뿐 아니라 다양한 네트워크 상태에서 메시지를 교화낳고 전달할 수 있으며, 무거운 작업을 하고 있는 상황에서도 가용성을 제공한다.
     *
     *       1. 반응성(responsive) : 리액티브 시스템은 빠를 뿐 아니라 더 중요한 특징으로 일정하고 예상할 수 있는 반응 시간을 제공한다. 결과적으로
     *       사용자가 기대치를 가질 수 있다. 기대치를 통해 사용자의 확신이 증가하면서 사용할 수 있는 애플리케이션이라는 확인을 제공할 수 있다.
     *
     *       2. 회복성(resilient) : 장애가 발생해도 시스템은 반응해야한다. 컴포넌트 실행 복제, 여러 컴포넌트의 시간(발송자와 수신자가 독립적인 생명
     *       주기를 가짐)과 공간(발송자와 수신자가 다른 프로세스에서 실행됨) 분리, 각 컴포넌트가 비동기적으로 작업을 다른 컴포넌트에 위임하는 등
     *       리액티브 매니페스토는 회복성을 달성할 수 있는 다양한 기법을 제시한다.
     *
     *       3. 탄력성(elastic) : 애플리케이션 생명 주기 동안 다양한 작업 부하를 받게 되는데 이 다양한 작업 부하고 애플리케이션의 반응성이 위협받을 수 있다.
     *       리액티브 시스템에서는 무서운 작업 부하가 발생하면 자동으로 관련 컴포넌트에 할당된 자원 수를 늘린다.
     *
     *       4. 메시지 주도(Message-driven) : 회복성과 탄력성을 지원하려면 약한 결합, 고립, 위치 투명성 등을 지원할 수 있도록 시스템을 구성하는 컴포
     *       넌트의 경계를 명확하게 정의해야 한다. 비동기 메시지를 전달해 컴포넌트 끼리의 통신이 이뤄진다. 이 덕분에 회복성(장애를 메시지로 처리)과 탄력성(
     *       주고 받은 메시지의 수를 감시하고 메시지의 양에 따라 적절하게 리소스를 할당)을 얻을 수 있다.
     *
     * 아래는 네 가지 기능이 어떤 관계를 맺고 있으며 어떻게 다른 기능에 의존하는지 보여준다. 이들 원칙은 작은 애플리케이션의 내부 구조에서 여러 애플리케이션이
     * 어떻게 큰 시스템을 구성할지에 이르기까지 다양한 크기의 애플리케이션 상황에 적용할 수 있다. 하지만 이들 원칙을 어디에서 어떤 수준으로 적용할 수 있는지
     * 확인할 필요가 있다.
     *
     *      > 반응성 : 시스템은 가능한한 적정 시간 안에 반응한다. 반응성이 뒷받침되어야 사용성을 높일 수 있다.
     *      > 회복성 : 장애 시에도 시스템의 반응성은 유지된다.
     *      > 탄력성 : 다양한 작업 부하에도 시스템 반응성이 유지된다. 입력 속도가 바뀐다면 이들 입력 관련 서비스에 할당되니 자원을 늘리거나 줄임으로
     *      반응할 수 있다.
     *      > 메시지 주도 : 컴포넌트 간의 약한 결합, 고립, 위치 투명성이 유지되도록 시스템은 비동기 메시지 전달에 의존한다.
     *
     *
     *
     *                      > 17.1.1 애플리케이션 수준의 리액티브
     * 애플리케이션 수준 컴포넌트의 리액티브 프로그래밍의 주요 기능은 비동기로 작업을 수행할 수 있다는 점이다. 이 장의 일부 부분에서는 이벤트 스트림을 블록하지
     * 않고 비동기로 처리하는 것이 최신 멀티코어 CPU의 사용률을 극대화( 엄밀히 따지면 내부적으로 경쟁하는 CPU의 쓰레드 사용률) 할 수 있는 방법이다.
     * 이 목표를 달성할 수 있도록 리액티브 프레임워크와 라이브러리는 쓰레드( 상대적으로 비싸고 희귀한 자원)를 퓨터, 액터, 일련의 콜백을 발생시키는 이벤트
     * 루프 등과 공유하고 처리할 이벤트를 변환하고 관리한다.
     *
     * 이들 기술은 쓰레드보다 가벼울 뿐 아니라 개발자에게 큰 이득을 제공한다. 개발자 입장에서는 이들 기술을 이용함으로 동시, 비동기 애플리케이션 구현의 추상
     * 수준을 높일 수 있으므로 동기 블록, 경쟁 조건 데드락 같은 저 수준의 멀티 쓰레드 문제를 직접 처리할 필요가 없어지면서 비즈니스 요구사항을 구현하는 데
     * 더 집중할 수 있다.
     *
     * 쓰레드를 다시 쪼개는 종류의 기술을 이용할 떄는 메인 이벤트 루프 안에서는 절대 동작을 블록하지 않아야 한다는 중요한 전제 조건이 항상 따른다. 데이터베이스나
     * 파일 시스템 접근, 작업 완료까지 얼마나 걸릴지 예측이 힘든 원격 서비스 호출 등 모든 I/O 관련 동작이 블록 동작에 속한다.
     *
     * 예를 들어 두 쓰레드를 포함한 풀이 있고 이벤트 스트림 세 개를 처리하는 상황을 가정해보자. 한 번에 오직 두 개의 스트림을 처리할 수 있는 상황이므로 가능하면
     * 이들 스트림은 두 쓰레드를 효율적이고 공정하게 공유해야한다. 어떤 스트림의 이벤트를 처리하다보니 파일 시스템 기록 또는 블록되는 API를 이용해서 데이터베이스에서
     * 파일을 가져오는 등 느린 I/O 작업이 시작됐다. 이런 상황에서 쓰레드 2는 I/O 동작이 끝나길 기다리며 소모된다. 쓰레드 1은 첫 번째 스트림을 처리할 수 있지만
     * 이전에 시작되니 블록 정작이 끝나기 전까지 세 번쨰 스트림은 처리되지 못한다.
     *
     * RxJava 같은 리액티브 프레임워크는 별도로 지정된 쓰레드 풀에서 블록 동작을 실행시켜 이 문제를 해결한다. 메인 풀의 모든 쓰레드는 방해받지 않고 실행
     * 되므로 모든 CPU 코어가 가장 최적의 상황에서 동작할 수 있다. CPU 관련 작업과 I/O 관련 작업을 분리하면 조금 더 정밀하게 풀의 크기 등을 설정할 수 있고
     * 두 종류의 작업의 성능을 관찰할 수 있다.
     *
     * 리액티브 원칙을 따르는 것은 리액티브 프로그래밍의 일부분일 뿐이며 가장 어려운 부분은 따로 있다. 리액티브 시스템을 만들려면 훌륭하게 설계된 리액티브
     * 애플리케이션 집합이 서로 잘 조화를 이루게 만들어야 한다.
     *
     *
     *
     *                          > 17.1.2 시스템 수준의 리액티브
     * 리액티브 시스템은 여러 애플리케이션이 한 개의 일관적인, 회복할 수 있는 플랫폼을 구성할 수 있게 해줄 뿐 아니라 이들 애플리케이션 중 하나가 실패해도
     * 전체 시스템은 계속 운영될 수 있도록 도와주는 소프트웨어 아키텍쳐다. 리액티브 애플리케이션은 비교적 짧은 시간 동안만 유지되는 데이터 스트림에 기반한 연산을
     * 수행하며 보통 이벤트 주도로 분류된다. 반면 리액티브 시스템은 애플리케이션을 조립하고 상호 소통을 조절한다. 리액티브 시스템의 주요 속성으로 메시지 주도를
     * 꼽을 수 있다.
     *
     * 메시지는 정의된 목적지는 하나를 향하는 반면, 이벤트는 관련 이벤트를 관찰하도록 등록한 컴포넌트가 수신한다는 점이 다르다. 리액티브 시스템에서는 수신자와
     * 발신자가 각각 수신 메시지, 발신 메시지와 결합하지 않도록 이들 메시지를 비동기로 처리해야 한다. 각 컴포넌트를 완전히 고립하려면 이들이 결합되지 않도록 해야
     * 하며 그래야만 시스템이 장애(회복성)와 높은 부하(탄력성)에서도 반응성을 유지할 수 있다.
     *
     * 좀 더 정확히 말하면 이랙티브 아키텍처에서는 컴포넌트에서 발생한 장애를 고립시킴으로 문제가 다른 컴포넌트로 전파되면서 전체 시스템 장애를 이어지는 것을
     * 막음으로 회복성을 제공한다. 이런 맥락에서 회복성은 결함 허용 능력과 같은 의미를 지닌다. 시스템에 장애가 발생했을 때 서서히 성능이 저하되는 것이 아니라
     * 문제를 격리함으로 장애에서 완전히 복구되어 건강한 상태로 시스템이 돌아온다. 이런 마법은 에러 전파를 방지하고 이들을 메시지로 바꿔서 다른 컴포넌트로 보내는 등
     * 감독자 역할을 수행함으로 이뤄진다. 이렇게 컴포넌트 자체로 문제가 한정되고 외부로는 안정성을 보장하는 방식으로 문제를 관리할 수 있다.
     *
     * 고립과 비결합이 회복성이 핵심이라면 탄력성의 핵심은 위치 투명성이다. 위치 투명성은 리액티브 시스템의 모든 컴포넌트가 수신자의 위치에 상관없이 다른 모든
     * 서비스와 통신할 수 있음을 의미한다. 위치 투명성 덕분에 시스템을 복제할 수 있으며 현재 작업 부하에 따라 (자동으로) 애플리케이션을 확장할 수 있다.
     * 위치를 따지지 않는 확장성은 리액티브 애플리케이션(시간에 기반한 비동기, 동시적, 비결합)과 리액티브 시스템(위치 투명성을 통한 공간적 비결합할 수 있음)
     * 의 또 다른 차이를 보여준다.
     *
     *
     *
     *                      > 17.2 리액티브 스트림과 플로 API
     *
     * 리액티브 프로그래밍은 리액티브 스트림을 사용하는 프로그래밍이다. 리액티브 스트림은 잠재적으로 무한의 비동기 데이터를 순서대로, 그리고 블록하지 않는
     * 역압력을 전제해 처리하는 표준 기술이다. 역압력은 발행-구독 프로토콜에서 이벤트 스트림의 구독자가 발행자가 이벤트를 제공하는 속도보다 느린 속도로 이벤트로
     * 소비하면서 문제가 발생하지 않도록 보장하는 장치이다. 이런 상황이 발생했을 때 부하가 발생한 컴포넌트가 완전 불능이 되거나 예기치 않는 방식으로 이벤트를
     * 잃어버리는 등의 문제가 발생하지 않는다. 부하가 발생한 컴포넌트는 이벤트 발생 속도를 늦추라고 알리거나, 얼마나 많은 이벤트를 수신할 수 있는지를 알리거나,
     * 다른 데이터를 받기 전에 기존의 데이터를 처리하는 데 얼마나 시간이 걸리는지를 업스트림 발행자에게 알릴 수 있어야 한다.
     *
     * 스트림 처리의 비동기적인 특성상 역압력 기능의 내장은 필수라는 사실을 알 수 있다. 실제 비동기 작업이 실행되는 동안 시스템에는 암묵적으로 블록 API로
     * 인해 역압력이 제공되는 것이다. 안타깝게도 비동기 작업을 실행하는 동안에는 그 작업이 완료될 떄까지 다른 유용한 작업을 실행할 수 없으므로 기다리면서 많은
     * 자원을 낭비하게 된다. 반면 비동기 API를 사용하면 하드웨어 사용률을 극대화할 수 있지만 다른 느린 다운 스트림 컴포넌트에 너무 큰 부하를 줄 가능성도
     * 생긴다. 따라서 이런 상황을 방지할 수 있도록 역압력이나 제어 흐름 기법이 필요하다. 이들 기법은 데이터 수신자가 쓰레드를 블록하지 않고도 데이터 수신자가
     * 처리할 수 없을 만큼 많은 데이터를 받는 일을 방지하는 프로토콜을 제공한다.
     *
     * 자바 9의 새로운 java.util.concurrent.Flow 클래스 뿐만 아니라 Akka 스트림(라이트벤드), 리액터(Pivotal), RxJava(넷플릭스), Vert.x(레드햇)
     * 등 많은 서드 파티 라이브러리에서 이들 인터페이스를 구현한다.
     *
     *
     *
     *                          > 17.2.1 Flow 클래스 소개
     * 자바 9에서는 리액티브 프로그래밍을 제공하는 클래스 java.util.concurrent.Flow를 추가했다. 이 클래스는 정적 컴포넌트 하나를 포함하고 있으며
     * 인스턴스화할 수 없다. 리액티브 스트림 프로젝트의 표준에 따라 프로그래밍 발행-구독 모델을 지원할 수 있도록 Flow는 중첩된 네 개의 인터페이스를 포함한다.
     *
     *      1. Publisher
     *      2. Subscriber
     *      3. Subscription
     *      4. Processor
     *
     * Publisher가 발행하면 Subscriber가 한 개씩 또는 한 번에 여러 항목을 소비하는데, Subscription이 과정을 관리할 수 있도록 Flow 클래스는
     * 관련된 인터페이스와 정적 메소드를 제공한다. Publisher는 수많은 일련의 이벤트를 제공할 수 있지만 Subscriber의 요구사항에 따라 역압력 기법에 의해
     * 이벤트 속도가 제한된다. Publisher는 자바의 함수형 인터페이스로, Subscriber는 Publisher가 발행한 이벤트 리스너로 자신을 등록할 수 있다.
     * Subscription은 Publisher와 Subscriber 사이의 제어 흐름, 역압력을 관리한다.
     *
     * 반면 Subscriber 인터페이스는 Publisher가 관련 이벤트를 발행할 떄 호출할 수 있도록 콜백 메소드 네 개를 정의한다.
     *
     *          public interface Subscriber<T> {
     *              void onSubscribe(Subscription s);
     *              void onNext(T t);
     *              void onError(Throwable t);
     *              void onComplete();
     *          }
     *
     * 이들 이벤트는 다음 프로토콜에서 정의한 순서로 지정된 메소드 호출을 통해 발행되어야 한다.
     *
     *          onSubscribe onNext* (onError || onComplete)?
     *
     * 위 표기는 onSubscribe 메소드가 항상 처음 호출되고 이어서 onNext가 여러 번 호출될 수 있음을 의미한다. 이벤트 스트림은 영원히 지속되거나 아니면
     * onComplete 콜백을 통해 더 이상의 데이터가 없도 종료됨을 알릴 수 있으며 또는 Publisher에 장애가 발생했을 때는 onError를 호출할 수 있다.
     * (ex.터미널로 문자열을 읽을 때 파일의 끝이나 I/O 에러와 비슷하다고 생각하면 쉽다. )
     *
     * Subscriber가 Publisher에 자신을 등록할 때 Puslisher는 처음으로 onSubscribe 메소드를 호출해서 Subscription 객체를 전달한다. Subscription
     * 인터페이스는 메소드 두 개를 정의한다. Subscription은 첫 번째 메소드로 Publisher에게 주어진 개수의 이벤트를 처리할 준비가 되었음을 알릴 수 있다.
     * 두 번째 메소드로는 Subscription을 취소, 즉, Publisher에게 더 이상 이벤트를 받지 않음을 통지한다.
     *
     *          public interface Subscription {
     *              void request(long n);
     *              void cancel();
     *          }
     *
     * 자바 9 Flow 명세서는 이들 인터페이스 구현이 어떻게 서로 협력해야 하는지를 설명하는 규칙 집합을 정의한다.
     *
     *      - Publisher는 반드시 Subscription의 request 메소드에 정의된 개수 이하의 요소만 Subscriber에 전달해야 한다. 하지만 Publisher는
     *      지정된 개수보다 적은 수의 요소를 onNext로 전달할 수 있으며 동작이 성공적으로 끝났으면 onComplete를 호출하고 문제가 발생하면 onError를
     *      호출해서 Subscription을 종료할 수 있다.
     *
     *      - Subscriber는 요소를 받아 처리할 수 있음을 Publisher에 알려야한다. 이런 방식으로 Subscriber는 Publisher에 역압력을 행사할 수 있고
     *      Subscriber가 관리할 수 없이 너무 많은 요소를 받는 일을 피할 수 있다. 더욱이 onComplete나 onError 신호를 처리하는 상황에서 Subscriber
     *      는 Publisher나 Subscription의 어떤 메소드도 호출할 수 없으며 Subscription이 취소되었다고 가정해야한다. 마지막으로 Subscriber는
     *      Subscription.request() 메소드 호출 없이도 언제든 종료 시그널을 받을 준비가 되어있어야 하며 Subscription.cancel()이 호출된 이후에라도
     *      한 개 이상의 onNext를 받을 준비가 되어 있어야 한다.
     *
     *      - Publisher와 Subscriber는 정확하게 Subscription을 공유해야 하며 각가의 고유한 역할을 수행해야 한다. 그러려면 onSubscribe와 onNext
     *      메소드에서 Subscirber는 request 메소드를 동기적으로 호출할 수 있어야 한다. 표준에서는 Subscriber.cancel() 메소드는 몇 번을 호출해도 한 번
     *      호출한 것과 같은 효과를 가져야 하며, 여러 번 이 메소드를 호출해도 다른 추가 호출에 별 여여향이 없도록 쓰레드에 안전해야한다고 명시한다. 같은
     *      Subscriber 객체에 다시 가입하는 것은 권장하지 않지만 이런 상황에서 예외가 발생해야 한다고 명세서가 강제하지는 않는다. 이전에 취소된 가입이
     *      영구적으로 적용되었다면 이후의 기능에 영향을 주지 않을 가능성도 있기 때문이다.
     *
     *
     *      메인                    Publisher                    Subscriber                               Subscription
     *       ⎮                        ⎮                             ⎮                                          ⎮
     *       ⎮                        ⎮                             ⎮                                          ⎮
     *       ⎮  subscribe(Subscriber) ⎮                             ⎮                                          ⎮
     *       ⎮----------------------->⎮ onSubscriber(Subscription)  ⎮                                          ⎮
     *       ⎮                        ⎮---------------------------> ⎮        request(int) - 역얍력               ⎮
     *       ⎮                        ⎮                             ⎮  ------------------------------------->  ⎮
     *       ⎮                        ⎮                             ⎮              onNext(data)                ⎮
     *       ⎮                        ⎮                             ⎮  <-------------------------------------  ⎮
     *       ⎮                        ⎮                             ⎮              onNext(data)                ⎮
     *       ⎮                        ⎮                             ⎮  <-------------------------------------  ⎮
     *       ⎮                        ⎮                             ⎮              request(int)                ⎮
     *       ⎮                        ⎮                             ⎮  ------------------------------------->  ⎮
     *       ⎮                        ⎮                             ⎮              onNext(data)                ⎮
     *       ⎮                        ⎮                             ⎮  <-------------------------------------  ⎮
     *       ⎮                        ⎮                             ⎮            onComplete/onError            ⎮
     *       ⎮                        ⎮                             ⎮  <-------------------------------------  ⎮
     *         onSubscribe onNext* (onError|onComplete)             ⎮                                          ⎮
     *
     * Flow 클래스의 네 번째이자 가장 마지막 멤버 Processor 인터페이스는 단지 Publisher와 Subscriber를 상속받을 뿐 아무 메소드도 추가하지 않는다.
     *
     *               public interface Processor<T, R> extends Subscriber<T>, Publisher<R>{ }
     *
     * 실제 이 인터페이스는 리액티브 스트림에서 처리하는 이벤트의 변환 단계를 나타낸다. Processor가 에러를 수신하면 이로부터 회복하거나(그리고 Subscription은
     * 취소로 간주) 즉시 onError 신호로 모든 Subscriber에 에러를 전파할 수 있다. 마지막 Subscriber가 Subscription을 취소하면 Processor는
     * 자신의 업스트림 Subscription도 취소함으로 취소 신호를 전파해야 한다.
     *
     * 자바 플로 9 API/리액티브 스트림 API에서는 Subscriber 인터페이스의 모든 메소드 구현이 Publisher를 블록하지 않도록 강제하지만 이들 메소드가
     * 이벤트를 동기적으로 처리해야하는지 아니면 비동기적으로 처리해야하는지는 지정하지 ㅇ낳는다. 하지만 이들 인터페이스에 정의된 모든 메소드는 void를 반환하므로
     * 온전히 비동기 방식으로 이들 메소드를 구현할 수 있다.
     *
     *
     *                     > 17.2.2 첫 번째 리액티브 애플리케이션 만들기
     * Flow 클래스에 정의된 인터페이스는 대부분 직접 구현하도록 의도된 것이 아니다. 그럼에도 자바 9 라이브러리는 이들 인터페이스를 구현하는 클래스를 제공하지 않는다.
     * RxJava 등의 리액티브 라이브러리에서는 이들 인터페이스를 구현했다. 자바 9 java.util.concurrency.Flow 명세는 이들 라이브러리가 준수해야할 규칙과
     * 다양한 리액티브 라이브러리를 이용해 개발된 리액티브 애플리케이션이 서로 협동하고 소통할 수 있는 공용어를 제시한다. 더욱이 이들 리액티브 라이브러리는 보통
     * 추가적인 기능을 제공한다. (java.util.concurrency.Flow 인터페이스에 정의 최소 하위 집합을 넘어  리액티브 스트림을 변형하고 합치는 기능과 관련된 클래스와 메소드 등).
     *
     *
     */
    }
}
