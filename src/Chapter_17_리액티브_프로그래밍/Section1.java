package Chapter_17_리액티브_프로그래밍;

public class Section1 {
    public static void main(String[] args) {
    /**
     *              > 리액티브 프로그래밍
     *
     *  리액티브 프로그래밍은 아래의 세 가지 이유로 최근 대두되었다
     *
     *      1. 빅데이터 : 보통 빅데이터는 패타바이트 단위로 구성되며 매일 증가한다.
     *      2. 다양한 환경 : 모바일 디바이스에서 수천 개의 멀티 코어 프로세서로 실행되는 클라우드 기반 클러스터에 이르기까지 다양한 환경에 애플리케이션이
     *      배포된다.
     *      3. 사용 패턴 : 사용자는 1년 내내 항상 서비스를 이용할 수 있으며 밀리초 단위의 응답 시간을 기대한다.
     *
     *  지금까지의 아키텍쳐로는 이들을 만족시키기 어렵다.
     *
     *  리액티브 프로그래밍에서는 다양한 시스템과 소스에서 들어오는 데이터 항목 스트림을 비동기적으로 처리하고 합쳐서 이런 문제를 해결하낟. 실제로 이런 패러다임에
     *  맞게 설계된 애플리케이션은 발생한 데이터 항목을 바로 처리함으로써 사용자에게 높은 응답성을 제공한다. 게다가 한 개의 컴포넌트나 애플리케이션뿐만 아니라
     *  전체의 리액티브 시스템을 구성하는 여러 컴포넌트를 조절하는 데도 리액티브 기법을 사용한다. 이런 방식으로 구성된 시스템에서는 고장, 정전 같은 상태에
     *  대처할 뿐 아니라 다양한 네트워크 상태에서 메시지를 교화낳고 전달할 수 있으며, 무거운 작업을 하고 있는 상황에서도 가용성을 제공한다.
     *
     *       1. 반응성(responsive) : 리액티브 시스템은 빠를 뿐 아니라 더 중요한 특징으로 일정하고 예상할 수 있는 반응 시간을 제공한다. 결과적으로
     *       사용자가 기대치를 가질 수 있다. 기대치를 통해 사용자의 확신이 증가하면서 사용할 수 있는 애플리케이션이라는 확인을 제공할 수 있다.
     *
     *       2. 회복성(resilient) : 장애가 발생해도 시스템은 반응해야한다. 컴포넌트 실행 복제, 여러 컴포넌트의 시간(발송자와 수신자가 독립적인 생명
     *       주기를 가짐)과 공간(발송자와 수신자가 다른 프로세스에서 실행됨) 분리, 각 컴포넌트가 비동기적으로 작업을 다른 컴포넌트에 위임하는 등
     *       리액티브 매니페스토는 회복성을 달성할 수 있는 다양한 기법을 제시한다.
     *
     *       3. 탄력성(elastic) : 애플리케이션 생명 주기 동안 다양한 작업 부하를 받게 되는데 이 다양한 작업 부하고 애플리케이션의 반응성이 위협받을 수 있다.
     *       리액티브 시스템에서는 무서운 작업 부하가 발생하면 자동으로 관련 컴포넌트에 할당된 자원 수를 늘린다.
     *
     *       4. 메시지 주도(Message-driven) : 회복성과 탄력성을 지원하려면 약한 결합, 고립, 위치 투명성 등을 지원할 수 있도록 시스템을 구성하는 컴포
     *       넌트의 경계를 명확하게 정의해야 한다. 비동기 메시지를 전달해 컴포넌트 끼리의 통신이 이뤄진다. 이 덕분에 회복성(장애를 메시지로 처리)과 탄력성(
     *       주고 받은 메시지의 수를 감시하고 메시지의 양에 따라 적절하게 리소스를 할당)을 얻을 수 있다.
     *
     * 아래는 네 가지 기능이 어떤 관계를 맺고 있으며 어떻게 다른 기능에 의존하는지 보여준다. 이들 원칙은 작은 애플리케이션의 내부 구조에서 여러 애플리케이션이
     * 어떻게 큰 시스템을 구성할지에 이르기까지 다양한 크기의 애플리케이션 상황에 적용할 수 있다. 하지만 이들 원칙을 어디에서 어떤 수준으로 적용할 수 있는지
     * 확인할 필요가 있다.
     *
     *      > 반응성 : 시스템은 가능한한 적정 시간 안에 반응한다. 반응성이 뒷받침되어야 사용성을 높일 수 있다.
     *      > 회복성 : 장애 시에도 시스템의 반응성은 유지된다.
     *      > 탄력성 : 다양한 작업 부하에도 시스템 반응성이 유지된다. 입력 속도가 바뀐다면 이들 입력 관련 서비스에 할당되니 자원을 늘리거나 줄임으로
     *      반응할 수 있다.
     *      > 메시지 주도 : 컴포넌트 간의 약한 결합, 고립, 위치 투명성이 유지되도록 시스템은 비동기 메시지 전달에 의존한다.
     *
     *
     *
     *                      > 17.1.1 애플리케이션 수준의 리액티브
     * 애플리케이션 수준 컴포넌트의 리액티브 프로그래밍의 주요 기능은 비동기로 작업을 수행할 수 있다는 점이다. 이 장의 일부 부분에서는 이벤트 스트림을 블록하지
     * 않고 비동기로 처리하는 것이 최신 멀티코어 CPU의 사용률을 극대화( 엄밀히 따지면 내부적으로 경쟁하는 CPU의 쓰레드 사용률) 할 수 있는 방법이다.
     * 이 목표를 달성할 수 있도록 리액티브 프레임워크와 라이브러리는 쓰레드( 상대적으로 비싸고 희귀한 자원)를 퓨터, 액터, 일련의 콜백을 발생시키는 이벤트
     * 루프 등과 공유하고 처리할 이벤트를 변환하고 관리한다.
     *
     * 이들 기술은 쓰레드보다 가벼울 뿐 아니라 개발자에게 큰 이득을 제공한다. 개발자 입장에서는 이들 기술을 이용함으로 동시, 비동기 애플리케이션 구현의 추상
     * 수준을 높일 수 있으므로 동기 블록, 경쟁 조건 데드락 같은 저 수준의 멀티 쓰레드 문제를 직접 처리할 필요가 없어지면서 비즈니스 요구사항을 구현하는 데
     * 더 집중할 수 있다.
     *
     * 쓰레드를 다시 쪼개는 종류의 기술을 이용할 떄는 메인 이벤트 루프 안에서는 절대 동작을 블록하지 않아야 한다는 중요한 전제 조건이 항상 따른다. 데이터베이스나
     * 파일 시스템 접근, 작업 완료까지 얼마나 걸릴지 예측이 힘든 원격 서비스 호출 등 모든 I/O 관련 동작이 블록 동작에 속한다.
     *
     * 예를 들어 두 쓰레드를 포함한 풀이 있고 이벤트 스트림 세 개를 처리하는 상황을 가정해보자. 한 번에 오직 두 개의 스트림을 처리할 수 있는 상황이므로 가능하면
     * 이들 스트림은 두 쓰레드를 효율적이고 공정하게 공유해야한다. 어떤 스트림의 이벤트를 처리하다보니 파일 시스템 기록 또는 블록되는 API를 이용해서 데이터베이스에서
     * 파일을 가져오는 등 느린 I/O 작업이 시작됐다. 이런 상황에서 쓰레드 2는 I/O 동작이 끝나길 기다리며 소모된다. 쓰레드 1은 첫 번째 스트림을 처리할 수 있지만
     * 이전에 시작되니 블록 정작이 끝나기 전까지 세 번쨰 스트림은 처리되지 못한다.
     *
     * RxJava 같은 리액티브 프레임워크는 별도로 지정된 쓰레드 풀에서 블록 동작을 실행시켜 이 문제를 해결한다. 메인 풀의 모든 쓰레드는 방해받지 않고 실행
     * 되므로 모든 CPU 코어가 가장 최적의 상황에서 동작할 수 있다. CPU 관련 작업과 I/O 관련 작업을 분리하면 조금 더 정밀하게 풀의 크기 등을 설정할 수 있고
     * 두 종류의 작업의 성능을 관찰할 수 있다.
     *
     * 리액티브 원칙을 따르는 것은 리액티브 프로그래밍의 일부분일 뿐이며 가장 어려운 부분은 따로 있다. 리액티브 시스템을 만들려면 훌륭하게 설계된 리액티브
     * 애플리케이션 집합이 서로 잘 조화를 이루게 만들어야 한다.
     *
     *
     *
     *                          > 17.1.2 시스템 수준의 리액티브
     * 리액티브 시스템은 여러 애플리케이션이 한 개의 일관적인, 회복할 수 있는 플랫폼을 구성할 수 있게 해줄 뿐 아니라 이들 애플리케이션 중 하나가 실패해도
     * 전체 시스템은 계속 운영될 수 있도록 도와주는 소프트웨어 아키텍쳐다. 리액티브 애플리케이션은 비교적 짧은 시간 동안만 유지되는 데이터 스트림에 기반한 연산을
     * 수행하며 보통 이벤트 주도로 분류된다. 반면 리액티브 시스템은 애플리케이션을 조립하고 상호 소통을 조절한다. 리액티브 시스템의 주요 속성으로 메시지 주도를
     * 꼽을 수 있다.
     *
     * 메시지는 정의된 목적지는 하나를 향하는 반면, 이벤트는 관련 이벤트를 관찰하도록 등록한 컴포넌트가 수신한다는 점이 다르다. 리액티브 시스템에서는 수신자와
     * 발신자가 각각 수신 메시지, 발신 메시지와 결합하지 않도록 이들 메시지를 비동기로 처리해야 한다. 각 컴포넌트를 완전히 고립하려면 이들이 결합되지 않도록 해야
     * 하며 그래야만 시스템이 장애(회복성)와 높은 부하(탄력성)에서도 반응성을 유지할 수 있다.
     *
     * 좀 더 정확히 말하면 이랙티브 아키텍처에서는 컴포넌트에서 발생한 장애를 고립시킴으로 문제가 다른 컴포넌트로 전파되면서 전체 시스템 장애를 이어지는 것을
     * 막음으로 회복성을 제공한다. 이런 맥락에서 회복성은 결함 허용 능력과 같은 의미를 지닌다. 시스템에 장애가 발생했을 때 서서히 성능이 저하되는 것이 아니라
     * 문제를 격리함으로 장애에서 완전히 복구되어 건강한 상태로 시스템이 돌아온다. 이런 마법은 에러 전파를 방지하고 이들을 메시지로 바꿔서 다른 컴포넌트로 보내는 등
     * 감독자 역할을 수행함으로 이뤄진다. 이렇게 컴포넌트 자체로 문제가 한정되고 외부로는 안정성을 보장하는 방식으로 문제를 관리할 수 있다.
     *
     *
     */
    }
}
