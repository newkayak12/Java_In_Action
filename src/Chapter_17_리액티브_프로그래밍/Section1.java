package Chapter_17_리액티브_프로그래밍;

import Chapter_17_리액티브_프로그래밍.test_17_2_2.*;
import io.reactivex.rxjava3.core.Observable;

import java.util.concurrent.TimeUnit;

public class Section1 {
    public static void main(String[] args) {
    /**
     *              > 리액티브 프로그래밍
     *
     *  리액티브 프로그래밍은 아래의 세 가지 이유로 최근 대두되었다
     *
     *      1. 빅데이터 : 보통 빅데이터는 패타바이트 단위로 구성되며 매일 증가한다.
     *      2. 다양한 환경 : 모바일 디바이스에서 수천 개의 멀티 코어 프로세서로 실행되는 클라우드 기반 클러스터에 이르기까지 다양한 환경에 애플리케이션이
     *      배포된다.
     *      3. 사용 패턴 : 사용자는 1년 내내 항상 서비스를 이용할 수 있으며 밀리초 단위의 응답 시간을 기대한다.
     *
     *  지금까지의 아키텍쳐로는 이들을 만족시키기 어렵다.
     *
     *  리액티브 프로그래밍에서는 다양한 시스템과 소스에서 들어오는 데이터 항목 스트림을 비동기적으로 처리하고 합쳐서 이런 문제를 해결하낟. 실제로 이런 패러다임에
     *  맞게 설계된 애플리케이션은 발생한 데이터 항목을 바로 처리함으로써 사용자에게 높은 응답성을 제공한다. 게다가 한 개의 컴포넌트나 애플리케이션뿐만 아니라
     *  전체의 리액티브 시스템을 구성하는 여러 컴포넌트를 조절하는 데도 리액티브 기법을 사용한다. 이런 방식으로 구성된 시스템에서는 고장, 정전 같은 상태에
     *  대처할 뿐 아니라 다양한 네트워크 상태에서 메시지를 교화낳고 전달할 수 있으며, 무거운 작업을 하고 있는 상황에서도 가용성을 제공한다.
     *
     *       1. 반응성(responsive) : 리액티브 시스템은 빠를 뿐 아니라 더 중요한 특징으로 일정하고 예상할 수 있는 반응 시간을 제공한다. 결과적으로
     *       사용자가 기대치를 가질 수 있다. 기대치를 통해 사용자의 확신이 증가하면서 사용할 수 있는 애플리케이션이라는 확인을 제공할 수 있다.
     *
     *       2. 회복성(resilient) : 장애가 발생해도 시스템은 반응해야한다. 컴포넌트 실행 복제, 여러 컴포넌트의 시간(발송자와 수신자가 독립적인 생명
     *       주기를 가짐)과 공간(발송자와 수신자가 다른 프로세스에서 실행됨) 분리, 각 컴포넌트가 비동기적으로 작업을 다른 컴포넌트에 위임하는 등
     *       리액티브 매니페스토는 회복성을 달성할 수 있는 다양한 기법을 제시한다.
     *
     *       3. 탄력성(elastic) : 애플리케이션 생명 주기 동안 다양한 작업 부하를 받게 되는데 이 다양한 작업 부하고 애플리케이션의 반응성이 위협받을 수 있다.
     *       리액티브 시스템에서는 무서운 작업 부하가 발생하면 자동으로 관련 컴포넌트에 할당된 자원 수를 늘린다.
     *
     *       4. 메시지 주도(Message-driven) : 회복성과 탄력성을 지원하려면 약한 결합, 고립, 위치 투명성 등을 지원할 수 있도록 시스템을 구성하는 컴포
     *       넌트의 경계를 명확하게 정의해야 한다. 비동기 메시지를 전달해 컴포넌트 끼리의 통신이 이뤄진다. 이 덕분에 회복성(장애를 메시지로 처리)과 탄력성(
     *       주고 받은 메시지의 수를 감시하고 메시지의 양에 따라 적절하게 리소스를 할당)을 얻을 수 있다.
     *
     * 아래는 네 가지 기능이 어떤 관계를 맺고 있으며 어떻게 다른 기능에 의존하는지 보여준다. 이들 원칙은 작은 애플리케이션의 내부 구조에서 여러 애플리케이션이
     * 어떻게 큰 시스템을 구성할지에 이르기까지 다양한 크기의 애플리케이션 상황에 적용할 수 있다. 하지만 이들 원칙을 어디에서 어떤 수준으로 적용할 수 있는지
     * 확인할 필요가 있다.
     *
     *      > 반응성 : 시스템은 가능한한 적정 시간 안에 반응한다. 반응성이 뒷받침되어야 사용성을 높일 수 있다.
     *      > 회복성 : 장애 시에도 시스템의 반응성은 유지된다.
     *      > 탄력성 : 다양한 작업 부하에도 시스템 반응성이 유지된다. 입력 속도가 바뀐다면 이들 입력 관련 서비스에 할당되니 자원을 늘리거나 줄임으로
     *      반응할 수 있다.
     *      > 메시지 주도 : 컴포넌트 간의 약한 결합, 고립, 위치 투명성이 유지되도록 시스템은 비동기 메시지 전달에 의존한다.
     *
     *
     *
     *                      > 17.1.1 애플리케이션 수준의 리액티브
     * 애플리케이션 수준 컴포넌트의 리액티브 프로그래밍의 주요 기능은 비동기로 작업을 수행할 수 있다는 점이다. 이 장의 일부 부분에서는 이벤트 스트림을 블록하지
     * 않고 비동기로 처리하는 것이 최신 멀티코어 CPU의 사용률을 극대화( 엄밀히 따지면 내부적으로 경쟁하는 CPU의 쓰레드 사용률) 할 수 있는 방법이다.
     * 이 목표를 달성할 수 있도록 리액티브 프레임워크와 라이브러리는 쓰레드( 상대적으로 비싸고 희귀한 자원)를 퓨터, 액터, 일련의 콜백을 발생시키는 이벤트
     * 루프 등과 공유하고 처리할 이벤트를 변환하고 관리한다.
     *
     * 이들 기술은 쓰레드보다 가벼울 뿐 아니라 개발자에게 큰 이득을 제공한다. 개발자 입장에서는 이들 기술을 이용함으로 동시, 비동기 애플리케이션 구현의 추상
     * 수준을 높일 수 있으므로 동기 블록, 경쟁 조건 데드락 같은 저 수준의 멀티 쓰레드 문제를 직접 처리할 필요가 없어지면서 비즈니스 요구사항을 구현하는 데
     * 더 집중할 수 있다.
     *
     * 쓰레드를 다시 쪼개는 종류의 기술을 이용할 떄는 메인 이벤트 루프 안에서는 절대 동작을 블록하지 않아야 한다는 중요한 전제 조건이 항상 따른다. 데이터베이스나
     * 파일 시스템 접근, 작업 완료까지 얼마나 걸릴지 예측이 힘든 원격 서비스 호출 등 모든 I/O 관련 동작이 블록 동작에 속한다.
     *
     * 예를 들어 두 쓰레드를 포함한 풀이 있고 이벤트 스트림 세 개를 처리하는 상황을 가정해보자. 한 번에 오직 두 개의 스트림을 처리할 수 있는 상황이므로 가능하면
     * 이들 스트림은 두 쓰레드를 효율적이고 공정하게 공유해야한다. 어떤 스트림의 이벤트를 처리하다보니 파일 시스템 기록 또는 블록되는 API를 이용해서 데이터베이스에서
     * 파일을 가져오는 등 느린 I/O 작업이 시작됐다. 이런 상황에서 쓰레드 2는 I/O 동작이 끝나길 기다리며 소모된다. 쓰레드 1은 첫 번째 스트림을 처리할 수 있지만
     * 이전에 시작되니 블록 정작이 끝나기 전까지 세 번쨰 스트림은 처리되지 못한다.
     *
     * RxJava 같은 리액티브 프레임워크는 별도로 지정된 쓰레드 풀에서 블록 동작을 실행시켜 이 문제를 해결한다. 메인 풀의 모든 쓰레드는 방해받지 않고 실행
     * 되므로 모든 CPU 코어가 가장 최적의 상황에서 동작할 수 있다. CPU 관련 작업과 I/O 관련 작업을 분리하면 조금 더 정밀하게 풀의 크기 등을 설정할 수 있고
     * 두 종류의 작업의 성능을 관찰할 수 있다.
     *
     * 리액티브 원칙을 따르는 것은 리액티브 프로그래밍의 일부분일 뿐이며 가장 어려운 부분은 따로 있다. 리액티브 시스템을 만들려면 훌륭하게 설계된 리액티브
     * 애플리케이션 집합이 서로 잘 조화를 이루게 만들어야 한다.
     *
     *
     *
     *                          > 17.1.2 시스템 수준의 리액티브
     * 리액티브 시스템은 여러 애플리케이션이 한 개의 일관적인, 회복할 수 있는 플랫폼을 구성할 수 있게 해줄 뿐 아니라 이들 애플리케이션 중 하나가 실패해도
     * 전체 시스템은 계속 운영될 수 있도록 도와주는 소프트웨어 아키텍쳐다. 리액티브 애플리케이션은 비교적 짧은 시간 동안만 유지되는 데이터 스트림에 기반한 연산을
     * 수행하며 보통 이벤트 주도로 분류된다. 반면 리액티브 시스템은 애플리케이션을 조립하고 상호 소통을 조절한다. 리액티브 시스템의 주요 속성으로 메시지 주도를
     * 꼽을 수 있다.
     *
     * 메시지는 정의된 목적지는 하나를 향하는 반면, 이벤트는 관련 이벤트를 관찰하도록 등록한 컴포넌트가 수신한다는 점이 다르다. 리액티브 시스템에서는 수신자와
     * 발신자가 각각 수신 메시지, 발신 메시지와 결합하지 않도록 이들 메시지를 비동기로 처리해야 한다. 각 컴포넌트를 완전히 고립하려면 이들이 결합되지 않도록 해야
     * 하며 그래야만 시스템이 장애(회복성)와 높은 부하(탄력성)에서도 반응성을 유지할 수 있다.
     *
     * 좀 더 정확히 말하면 이랙티브 아키텍처에서는 컴포넌트에서 발생한 장애를 고립시킴으로 문제가 다른 컴포넌트로 전파되면서 전체 시스템 장애를 이어지는 것을
     * 막음으로 회복성을 제공한다. 이런 맥락에서 회복성은 결함 허용 능력과 같은 의미를 지닌다. 시스템에 장애가 발생했을 때 서서히 성능이 저하되는 것이 아니라
     * 문제를 격리함으로 장애에서 완전히 복구되어 건강한 상태로 시스템이 돌아온다. 이런 마법은 에러 전파를 방지하고 이들을 메시지로 바꿔서 다른 컴포넌트로 보내는 등
     * 감독자 역할을 수행함으로 이뤄진다. 이렇게 컴포넌트 자체로 문제가 한정되고 외부로는 안정성을 보장하는 방식으로 문제를 관리할 수 있다.
     *
     * 고립과 비결합이 회복성이 핵심이라면 탄력성의 핵심은 위치 투명성이다. 위치 투명성은 리액티브 시스템의 모든 컴포넌트가 수신자의 위치에 상관없이 다른 모든
     * 서비스와 통신할 수 있음을 의미한다. 위치 투명성 덕분에 시스템을 복제할 수 있으며 현재 작업 부하에 따라 (자동으로) 애플리케이션을 확장할 수 있다.
     * 위치를 따지지 않는 확장성은 리액티브 애플리케이션(시간에 기반한 비동기, 동시적, 비결합)과 리액티브 시스템(위치 투명성을 통한 공간적 비결합할 수 있음)
     * 의 또 다른 차이를 보여준다.
     *
     *
     *
     *                      > 17.2 리액티브 스트림과 플로 API
     *
     * 리액티브 프로그래밍은 리액티브 스트림을 사용하는 프로그래밍이다. 리액티브 스트림은 잠재적으로 무한의 비동기 데이터를 순서대로, 그리고 블록하지 않는
     * 역압력을 전제해 처리하는 표준 기술이다. 역압력은 발행-구독 프로토콜에서 이벤트 스트림의 구독자가 발행자가 이벤트를 제공하는 속도보다 느린 속도로 이벤트로
     * 소비하면서 문제가 발생하지 않도록 보장하는 장치이다. 이런 상황이 발생했을 때 부하가 발생한 컴포넌트가 완전 불능이 되거나 예기치 않는 방식으로 이벤트를
     * 잃어버리는 등의 문제가 발생하지 않는다. 부하가 발생한 컴포넌트는 이벤트 발생 속도를 늦추라고 알리거나, 얼마나 많은 이벤트를 수신할 수 있는지를 알리거나,
     * 다른 데이터를 받기 전에 기존의 데이터를 처리하는 데 얼마나 시간이 걸리는지를 업스트림 발행자에게 알릴 수 있어야 한다.
     *
     * 스트림 처리의 비동기적인 특성상 역압력 기능의 내장은 필수라는 사실을 알 수 있다. 실제 비동기 작업이 실행되는 동안 시스템에는 암묵적으로 블록 API로
     * 인해 역압력이 제공되는 것이다. 안타깝게도 비동기 작업을 실행하는 동안에는 그 작업이 완료될 떄까지 다른 유용한 작업을 실행할 수 없으므로 기다리면서 많은
     * 자원을 낭비하게 된다. 반면 비동기 API를 사용하면 하드웨어 사용률을 극대화할 수 있지만 다른 느린 다운 스트림 컴포넌트에 너무 큰 부하를 줄 가능성도
     * 생긴다. 따라서 이런 상황을 방지할 수 있도록 역압력이나 제어 흐름 기법이 필요하다. 이들 기법은 데이터 수신자가 쓰레드를 블록하지 않고도 데이터 수신자가
     * 처리할 수 없을 만큼 많은 데이터를 받는 일을 방지하는 프로토콜을 제공한다.
     *
     * 자바 9의 새로운 java.util.concurrent.Flow 클래스 뿐만 아니라 Akka 스트림(라이트벤드), 리액터(Pivotal), RxJava(넷플릭스), Vert.x(레드햇)
     * 등 많은 서드 파티 라이브러리에서 이들 인터페이스를 구현한다.
     *
     *
     *
     *                          > 17.2.1 Flow 클래스 소개
     * 자바 9에서는 리액티브 프로그래밍을 제공하는 클래스 java.util.concurrent.Flow를 추가했다. 이 클래스는 정적 컴포넌트 하나를 포함하고 있으며
     * 인스턴스화할 수 없다. 리액티브 스트림 프로젝트의 표준에 따라 프로그래밍 발행-구독 모델을 지원할 수 있도록 Flow는 중첩된 네 개의 인터페이스를 포함한다.
     *
     *      1. Publisher
     *      2. Subscriber
     *      3. Subscription
     *      4. Processor
     *
     * Publisher가 발행하면 Subscriber가 한 개씩 또는 한 번에 여러 항목을 소비하는데, Subscription이 과정을 관리할 수 있도록 Flow 클래스는
     * 관련된 인터페이스와 정적 메소드를 제공한다. Publisher는 수많은 일련의 이벤트를 제공할 수 있지만 Subscriber의 요구사항에 따라 역압력 기법에 의해
     * 이벤트 속도가 제한된다. Publisher는 자바의 함수형 인터페이스로, Subscriber는 Publisher가 발행한 이벤트 리스너로 자신을 등록할 수 있다.
     * Subscription은 Publisher와 Subscriber 사이의 제어 흐름, 역압력을 관리한다.
     *
     * 반면 Subscriber 인터페이스는 Publisher가 관련 이벤트를 발행할 떄 호출할 수 있도록 콜백 메소드 네 개를 정의한다.
     *
     *          public interface Subscriber<T> {
     *              void onSubscribe(Subscription s);
     *              void onNext(T t);
     *              void onError(Throwable t);
     *              void onComplete();
     *          }
     *
     * 이들 이벤트는 다음 프로토콜에서 정의한 순서로 지정된 메소드 호출을 통해 발행되어야 한다.
     *
     *          onSubscribe onNext* (onError || onComplete)?
     *
     * 위 표기는 onSubscribe 메소드가 항상 처음 호출되고 이어서 onNext가 여러 번 호출될 수 있음을 의미한다. 이벤트 스트림은 영원히 지속되거나 아니면
     * onComplete 콜백을 통해 더 이상의 데이터가 없도 종료됨을 알릴 수 있으며 또는 Publisher에 장애가 발생했을 때는 onError를 호출할 수 있다.
     * (ex.터미널로 문자열을 읽을 때 파일의 끝이나 I/O 에러와 비슷하다고 생각하면 쉽다. )
     *
     * Subscriber가 Publisher에 자신을 등록할 때 Puslisher는 처음으로 onSubscribe 메소드를 호출해서 Subscription 객체를 전달한다. Subscription
     * 인터페이스는 메소드 두 개를 정의한다. Subscription은 첫 번째 메소드로 Publisher에게 주어진 개수의 이벤트를 처리할 준비가 되었음을 알릴 수 있다.
     * 두 번째 메소드로는 Subscription을 취소, 즉, Publisher에게 더 이상 이벤트를 받지 않음을 통지한다.
     *
     *          public interface Subscription {
     *              void request(long n);
     *              void cancel();
     *          }
     *
     * 자바 9 Flow 명세서는 이들 인터페이스 구현이 어떻게 서로 협력해야 하는지를 설명하는 규칙 집합을 정의한다.
     *
     *      - Publisher는 반드시 Subscription의 request 메소드에 정의된 개수 이하의 요소만 Subscriber에 전달해야 한다. 하지만 Publisher는
     *      지정된 개수보다 적은 수의 요소를 onNext로 전달할 수 있으며 동작이 성공적으로 끝났으면 onComplete를 호출하고 문제가 발생하면 onError를
     *      호출해서 Subscription을 종료할 수 있다.
     *
     *      - Subscriber는 요소를 받아 처리할 수 있음을 Publisher에 알려야한다. 이런 방식으로 Subscriber는 Publisher에 역압력을 행사할 수 있고
     *      Subscriber가 관리할 수 없이 너무 많은 요소를 받는 일을 피할 수 있다. 더욱이 onComplete나 onError 신호를 처리하는 상황에서 Subscriber
     *      는 Publisher나 Subscription의 어떤 메소드도 호출할 수 없으며 Subscription이 취소되었다고 가정해야한다. 마지막으로 Subscriber는
     *      Subscription.request() 메소드 호출 없이도 언제든 종료 시그널을 받을 준비가 되어있어야 하며 Subscription.cancel()이 호출된 이후에라도
     *      한 개 이상의 onNext를 받을 준비가 되어 있어야 한다.
     *
     *      - Publisher와 Subscriber는 정확하게 Subscription을 공유해야 하며 각가의 고유한 역할을 수행해야 한다. 그러려면 onSubscribe와 onNext
     *      메소드에서 Subscirber는 request 메소드를 동기적으로 호출할 수 있어야 한다. 표준에서는 Subscriber.cancel() 메소드는 몇 번을 호출해도 한 번
     *      호출한 것과 같은 효과를 가져야 하며, 여러 번 이 메소드를 호출해도 다른 추가 호출에 별 여여향이 없도록 쓰레드에 안전해야한다고 명시한다. 같은
     *      Subscriber 객체에 다시 가입하는 것은 권장하지 않지만 이런 상황에서 예외가 발생해야 한다고 명세서가 강제하지는 않는다. 이전에 취소된 가입이
     *      영구적으로 적용되었다면 이후의 기능에 영향을 주지 않을 가능성도 있기 때문이다.
     *
     *
     *      메인                    Publisher                    Subscriber                               Subscription
     *       ⎮                        ⎮                             ⎮                                          ⎮
     *       ⎮                        ⎮                             ⎮                                          ⎮
     *       ⎮  subscribe(Subscriber) ⎮                             ⎮                                          ⎮
     *       ⎮----------------------->⎮ onSubscriber(Subscription)  ⎮                                          ⎮
     *       ⎮                        ⎮---------------------------> ⎮        request(int) - 역얍력               ⎮
     *       ⎮                        ⎮                             ⎮  ------------------------------------->  ⎮
     *       ⎮                        ⎮                             ⎮              onNext(data)                ⎮
     *       ⎮                        ⎮                             ⎮  <-------------------------------------  ⎮
     *       ⎮                        ⎮                             ⎮              onNext(data)                ⎮
     *       ⎮                        ⎮                             ⎮  <-------------------------------------  ⎮
     *       ⎮                        ⎮                             ⎮              request(int)                ⎮
     *       ⎮                        ⎮                             ⎮  ------------------------------------->  ⎮
     *       ⎮                        ⎮                             ⎮              onNext(data)                ⎮
     *       ⎮                        ⎮                             ⎮  <-------------------------------------  ⎮
     *       ⎮                        ⎮                             ⎮            onComplete/onError            ⎮
     *       ⎮                        ⎮                             ⎮  <-------------------------------------  ⎮
     *         onSubscribe onNext* (onError|onComplete)             ⎮                                          ⎮
     *
     * Flow 클래스의 네 번째이자 가장 마지막 멤버 Processor 인터페이스는 단지 Publisher와 Subscriber를 상속받을 뿐 아무 메소드도 추가하지 않는다.
     *
     *               public interface Processor<T, R> extends Subscriber<T>, Publisher<R>{ }
     *
     * 실제 이 인터페이스는 리액티브 스트림에서 처리하는 이벤트의 변환 단계를 나타낸다. Processor가 에러를 수신하면 이로부터 회복하거나(그리고 Subscription은
     * 취소로 간주) 즉시 onError 신호로 모든 Subscriber에 에러를 전파할 수 있다. 마지막 Subscriber가 Subscription을 취소하면 Processor는
     * 자신의 업스트림 Subscription도 취소함으로 취소 신호를 전파해야 한다.
     *
     * 자바 플로 9 API/리액티브 스트림 API에서는 Subscriber 인터페이스의 모든 메소드 구현이 Publisher를 블록하지 않도록 강제하지만 이들 메소드가
     * 이벤트를 동기적으로 처리해야하는지 아니면 비동기적으로 처리해야하는지는 지정하지 ㅇ낳는다. 하지만 이들 인터페이스에 정의된 모든 메소드는 void를 반환하므로
     * 온전히 비동기 방식으로 이들 메소드를 구현할 수 있다.
     *
     *
     *                     > 17.2.2 첫 번째 리액티브 애플리케이션 만들기
     * Flow 클래스에 정의된 인터페이스는 대부분 직접 구현하도록 의도된 것이 아니다. 그럼에도 자바 9 라이브러리는 이들 인터페이스를 구현하는 클래스를 제공하지 않는다.
     * RxJava 등의 리액티브 라이브러리에서는 이들 인터페이스를 구현했다. 자바 9 java.util.concurrency.Flow 명세는 이들 라이브러리가 준수해야할 규칙과
     * 다양한 리액티브 라이브러리를 이용해 개발된 리액티브 애플리케이션이 서로 협동하고 소통할 수 있는 공용어를 제시한다. 더욱이 이들 리액티브 라이브러리는 보통
     * 추가적인 기능을 제공한다. (java.util.concurrency.Flow 인터페이스에 정의 최소 하위 집합을 넘어  리액티브 스트림을 변형하고 합치는 기능과 관련된 클래스와 메소드 등).
     *
     * 예시로 온도를 보고하는 간단한 프로그램을 확인해보자. 목표는 아래와 같다.
     *      1. TempInfo. 원격 온도계 흉내를 낸다. (0~99 사이의 화씨 온도를 임의로 만들어 연속적으로 보고)
     *      2. TempSubscriber 레포트를 관찰하면서 각 도시에 설치된 센서에서 보고한 온도 스트림을 출력한다.
     *
     *                  Chapter_17_리액티브_프로그래밍/test_17_2_2/TempInfo.java
     *
     * 간단한 도메인 모델을 정의한 다음에는 아래 예제처럼 Subscriber가 요청할 때마다 해당 도시의 온도를 전송하도록 Subscription을 구현한다.
     *
     *                  Chapter_17_리액티브_프로그래밍/test_17_2_2/TempSubscription.java
     *
     * 이번에는 새 요소를 얻을 때마다 Subscribption이 전달한 온도를 출력하고 새 레포트를 요청하는 Subscriber 클래스를 아래와 같이 구현한다.
     *
     *                  Chapter_17_리액티브_프로그래밍/test_17_2_2/TempSubscriber.java
     *
     * 아래 예제는 리액티브 애플리케이션이 동작하도록 Publisher를 만들고 TempSubScriber를 이용해서 Publisher에 구독하도록 한 코드이다.
     */
//        Publisher.getTemperatures("New York").subscribe(new TempSubscriber());
    /**
     *
     * 여기서 getTemperatures 메소드는 Subscriber를 인수로 받아 Subscriber의 onSubscribe 메소드를 호출 (새 TempSubscription 인스턴스를 인수로)
     * 한다. 람다의 시그니처가 Publisher의 함수형 인터페이스의 유일한 메소드와 같은 시그니처를 가지므로 자바 컴파일러는 자동으로 람다를 Publisher로
     * 바꿀 수 있다.
     *
     * 그러나 이 코드에는 문제가 있다. TempInfo 팩토리 메소드에서 임의로 에러를 발생시키는데 만약 임의로 에러를 발생시키는 코드를 없앤다면 스택오버플로가
     * 발생할 때까지 반복된다.
     *
     * 이 문제를 어떻게 해결할까? Executor를 TempSubscription으로 추가한다음 다른 쓰레드에서 TempSubscriber로 세 요소를 전달하는 방법이 있다.
     * 그러려면 TempSubscription을 바꿔야한다.
     *          Chapter_17_리액티브_프로그래밍/test_17_2_2/TempSubscription.request()
     *
     *
     *
     *
     *                      > 17.2.3 Processor로 데이터 변환하기
     *
     * Processor는 Subscriber이며 동시에 Publisher이다. 사실 Processor의 목적은 Publisher를 구독한 다음 수신한 데이터를 가공해서 다시
     * 제공하는 것이다. 화씨를 섭씨로 변환하는 예제를 구현해보자.
     *
     *                  Chapter_17_리액티브_프로그래밍/test_17_2_2/TempProcessor.java
     */
    System.out.println("\n------Processor------");
    Publisher.getCelsiusTemperatures("New York").subscribe(new TempSubscriber());
    /**
     *                      > 17.2.4 자바는 왜 Flow API 구현을 제공하지 않는가?
     * 자바 9의 Flow는 조금 이상하다. 자바 라이브러리는 보통 인터페이스와 구현을 제공하는 반면 플로 API는 구현을 제공하지 않으므로 우리가 직접 인터페이스를 구현했다.
     * 일례로 리스트 API를 보면 ArrayList<T>를 포함한 다양한 클래스가 List<T> 인터페이스를 구현한다. 조금더 엄밀하게 보면 ArrayList<T> 클래스는
     * List<T> 인터페이스를 구현하는 추상 클래스 AbstractList<T>를 상속받는다. 반면 자바 9에서는 Publisher<T> 인터페이스만 선언하고 구현을 제공하지
     * 않으므로 직접 인터페이스를 구현해야 한다. 인터페이스가 프로그래밍 구조를 만드는데 도움이 될 수 있지만 프로그램을 더 빨리 구현하는 데 도움이 되지 않는다.
     *
     * API를 만들 당시 RxJava 등 다양한 리액티브 스트림의 자바 코드 라이브러리가 이미 존재했기 때문이다. 원래 발행-구독 패러다임에 기반해 리액티브 프로그래밍을
     * 구현했지만, 이들 라이브러리는 독립적으로 개발되었고 서로 다른 이름 규칙과 API를 사용했다. 자바 9의 표준화 과정에서 기존처럼 자신만의 방법이 아닌 이들 라이브러리는
     * 공식적으로 java.util.concurrent.Flow의 인터페이스를 기반으로 리액티브 개념을 구현하도록 진화했다 이 표준화 작업 때문에 다양한 라이브러리가
     * 쉽게 협력할 수 있게 되었다.
     *
     *
     *                      > 17.3 리액티브 라이브러리 RxJava 사용하기
     * RxJava는 자바로 리액티브 애플리케이션을 구현하는 데 사용하는 라이브러리이다. RxJava는 java.util.concurrent.Flow를 지원하도록 개발되었다.
     * 자바에서 외부 라이브러리를 사용할 때 import에서 그 사실이 두드러진다.
     *
     *      import java.lang.concurrent.Flow.*;
     *      import io.reactivex.Observable;
     *
     * Publisher의 구현인 Observable 같은 클래스를 이용하려면 위와 같은 import를 사용해야한다.
     * 이 시점에서 중요한 아키텍쳐 속성을 살펴보면 좋은 시스템 아키텍쳐 스타일을 유지하려면 시스템에서 오직 일부에 사용된 개념의 세부 사항을 전체 시스템에서
     * 볼 수 있게 만들지 않아야 한다. 따라서 Observable의 추가 구조가 필요한 상황에서만 Observable을 사용하고 그렇지 않으면 Publisher의 인터페이스를
     * 사용하는 것이 좋다. 사실 List도 이 원칙이 적용되어 있다. 예를 들어 전달하는 값이 ArrayList라는 사실을 이미 알고 있지만 이 값의 파라미터 형식을
     * List로 설정함으로 구현 세부 사항을 밖으로 노출하지 않을 수 있다. 나중에 ArrayList를 LinkedList로 바꾸더라도 기존 코드를 크게 바꿀 필요가
     * 없게 된다. 마찬가지로 RxJava는 Flow.Publisher를 구현하는 두 클래스를 제공한다.
     *
     * RxJava 문서를 읽다보면 자바 9에서 리액티브 당김 기반 역압력 기능(request)이 있는 Flow를 포함하는 io.reactivex.Flowable 클래스를 확인할
     * 수 있다. 역압력은 Publisher가 너무 빠른 속도로 데이터를 발행하면서 Subscriber가 이를 감당할 수 없는 상황에 이르는 것을 방지하는 기능이다
     * 나머지 클래스는 역압력을 지원하지 않는 기존 버전의 RxJava에서 제공하던 Publisher.io.reactivex.Observable이다. 이 클래스는 단순한
     * 프로그램, 마우스 움직임 같은 사용자 인터페이스 이벤트에 더 적합하다. 이들 이벤트 스트림에는 역압력을 적용하기 어렵기 때문이다.
     * 이런 이유로 RxJava는 이벤트 스트림을 두 가지 구현 클래스로 제공한다.
     *
     *      {
     *          RxJava는 천 개 이하의 요소를 가진 스트림이나 마우스 움직임, 터치 이벤트 등 역압력을 적용하기 어려운 GUI 이벤트 그리고 자주 발생하지
     *          않는 종류의 이벤트에 역압력을 적용하지 말 것을 권장한다.
     *      }
     *
     * Flowable을 자세히 살펴보지는 않지만 대신 역압력을 사용하지 않는 상태에서 Observable 인터페이스를 사용하는 방법을 살펴볼 것이다. 모든 구독자는
     * 구독 객체의 request(Long.MAX_VALUE) 메소드를 이요해서 역압력 기능을 끌 수도 있다. 물론 Subscriber가 정해진 시간 안에 수신한 이벤트를
     * 모두 처리할 수 있다고 확신하는 상황이 아니고서야 역압력을 굳이 해제하지 않는 것이 좋다.
     *
     *
     *                  > 17.3.1 Observable 만들고 사용하기
     * Observable, Flowable은 다양한 종류의 리액티브 스트림을 편리하게 만들수 있도록 여러 팩토리 메소드를 제공한다. (Observable과 Flowable은
     * Publisher를 구현하므로 팩토리 메소드는 리액티브 스트림을 만든다.)
     */
    Observable<String> strings = Observable.just("first", "second");
    strings.subscribe(System.out::println);
    /**
     * 여기서 just() 팩토리 메소드는 한 개 이상의 요소를 이용해 이를 방출하는 Observable로 변환한다. Observable의 구독자는 onNext("first"),
     * onNext("second"), onComplete()의 순서로 메시지를 받는다.
     *
     * 사용자와 실시간으로 상호작용하면서 지정된 속도로 이벤트를 방출하는 상황에서 유용하게 사용할 수 있는 다른 Observable 팩토리 메소드도 있다.
     */
    Observable<Long> onPerSec = Observable.interval(1, TimeUnit.SECONDS);
    /**
     * 팩토리 메소드 interval은 onPerSec이라는 변수로 Observable을 반환해 할당한다. 이 Observable은 0에서 시작해 1초 간격으로 Long 형식의
     * 값을 무한으로 증가시키며 값을 방출한다.
     *
     * Rxjava에서는 Observable이 Flow API의 Publisher 역할을 하며 Observer는 Flow의 Subscriber 인터페이스 역할을 한다. RxJava Observer
     * 인터페이스는 자바 9의 Subscriber와 같은 메소드를 정의하며 onSubscribe 메소드가 Subscription 대신 Disposable 인수를 갖는 다는 점만 다르다.
     * 이전에 설명한 바와 같이 Observable은 역압력을 지원하지 않으므로 Subscription의 request 메소드를 포함하지 않는다.
     *
     * 하지만 RxJava의 API는 자바 9 네이티브 Flow API보다 유연하다., 예를 들어 다른 세 메소드는 생략하고 onNext 메소드의 시그니처에 해당하는
     * 람다 표현식을 전달해 Observable 을 구독할 수 있다. 즉 이벤트를 수신하는 Consumer의 onNext 메소드만 구현하고 나머지 완료, 에러 처리 메소드는
     * 아무것도 하지 않는 기본 동작을 가진 Observer를 만들어 Observable에 가입할 수 있다.
     */
    System.out.println("\n-------RxJava-------");
    onPerSec.subscribe(i -> System.out.println(TempInfo.fetch("NEWYORK")));
    /**
     * 위 코드를 실행하면 아무 것도 출력되지 않는데 이는 매 초마다 정보를 발행하는 Observable이 RxJava의 연산 쓰레드 풀 즉 데몬 쓰레드에서 실행되기
     * 떄문이다. main은 실행하자마자 따로 실행할 코드가 없으면 종료되고 프로그램이 종료되었으므로 어떤 결과를 출력하기도 전에 데몬쓰레드도 종료되면서 이런
     * 현상이 발생한다.
     *
     * 물론 sleep을 주는 방법도 있지만 현재 쓰레드에서 콜백을 호출하는 blockingSubscribe로 문제를 해결할 수 있다.
     */
    onPerSec.blockingSubscribe(i -> System.out.println(TempInfo.fetch("SEOUL")));
    /**
     *
     * 결국 에러가 나는데 이는 기능이 임의로 실패하기 때문이다. onError에서 에러 관리 기능이 없기 때문에 처리되지 않은 예외를 직접 보인다.
     * 이제 더 나아가 온도를 직접 출력하지 않고 사용자에게 팩토리 메소드를 제공해 매 초마다 온도를 방출하는 Observable을 반환할 것이다.
     *
     *
     *          Chapter_17_리액티브_프로그래밍/test_17_2_2/Publisher.java.Observable<TempInfo> getTemperature
     *
     * 필요한 이벤트를 전송하는 ObservableEmitter를 소비하는 함수로 Observable을 만들어 반환했다. RxJava의 ObservableEmitter 인터페이스는
     * RxJava의 기본 Emitter(onSubscribe 메소드가 빠진 Observer와 같음)를 상속한다.
     *
     *                             public interface Emitter<T> {
     *                                 void onNext(T t);
     *                                 void onError(Throwable t);
     *                                 void onComplete();
     *                             }
     *
     * Emitter는 새 Disposable을 설정하는 메소드와 시퀀스가 이미 다운스트림을 폐기했는지 확인하는 메소드 등을 제공한다.
     *
     * 내부적으로 매 초마다 증가하는 무한의 long을 발생하는 onePerSec과 같은 Observable을 구독했다. 우선 구독 함수 내에서는 ObservableEmitter
     * 인터페이스(subscribe 메소드의 인수로 넘겨짐)에서 제공하는 isDisposed 메소드를 이용해 소비된 Observer가 이미 폐기됐는지 확인한다.
     * 온도를 이미 다섯번 출력했으면 스틀미을 종료하면서 Observer를 완료한다. 그렇지 않으면 try/catch 블록 안에서 요청된 도시 최근 온도를 Observer로
     * 보낸다. 온도를 얻는 과정에서 에러가 발생하면 에러를 Observer로 전달한다.
     *
     *
     *                  Chapter_17_리액티브_프로그래밍/test_17_2_2/RxTemperature.java
     *
     * Observer는 TempSubscriber와 비슷하지만 단순하다. RxJava의 Observable은 역압력을 지원하지 않으므로 전달된 요소를 처리한 다음 추가 요소를
     * 요청하는 request() 메소드가 필요 없다.
     */
    System.out.println("\n\n------RxJava Observable-------");
    Observable<TempInfo> observable = RxTemperature.getTemperature("NewYork");
    observable.blockingSubscribe(new TempObserver());
    }
}
