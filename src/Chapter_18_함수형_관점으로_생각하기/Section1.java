package Chapter_18_함수형_관점으로_생각하기;

public class Section1 {
    public static void main(String[] args) {
    /**
     *                              > 18.1 시스템 구현과 유지보수
     * 지금까지 자바 8의 스트림을 사용하면 잠금(locking) 문제를 신경쓰지 않을 수 없다. 단, 자바 8의 스트림을 이용하려면 상태 없는 동작이어야 한다는 조건을
     * 만족해야한다. (즉, 스트림 처리 파이프 라인의 함수는 다른 누군가가 변수로 값을 바꿀 수 있는 상태에 있는 변수를 사용하지 않는다.). 또한 쉽게 유지
     * 보수 할 수 있으려면 어떠면 좋을까? 이는 결합성, 응집성으로 평가할 수 있다. 이런 점에서 함수형 프로그래밍이 제공하는 부작용 없음과 불변성이라는 개념이
     * 문제를 해결하는데 도움을 준다.
     *
     *
     *                              > 18.1.1 공유된 가변 데이터
     * 변수가 예상하지 못한 값을 갖는 이유는 결국 우리가 유지보수하는 시스템의 여러 메소드에서 공유된 가변 데이터 구조를 읽고 갱신하기 때문이다. 리스트를
     * 참조하는 여러 클래스가 있다고 가정하자 리스트의 소유자는 어느 클래스일까? 이들 중 하나의 클래스가 리스트를 갱신하면 어떻게 될까? 다른 클래스는 이를
     * 인지할까? 등등 공유 가변 데이터 구조를 사용하면 프로그램 전체에서 데이터 갱신 사실을 추적하기 어려워진다.
     *
     * 어떤 자료구조도 바꾸지 않는 시스템이 있다고 하자. 이러면 예상치 못하게 값이 바뀌는 경우가 드물것이다. 자신을 포함하는 클래스의 상태, 그리고 다른 객체의
     * 상태를 바꾸지 않으면 return을 통해서 자신의 결과를 반환하는 메소드를 순수 메소드, 부작용 없는 메소드라고 한다. 부작용이란 뭘까? 함수 내에 포함되지
     * 못한 기능을 부작용이라고 한다.
     *
     *      1. 자료구조를 고치거나 필드에 값을 할당(setter 메소드 같은 생성자 이외의 초기화 동작)
     *      2. 예외 발생
     *      3. 파일에 쓰기 등의 I/O 동작 수행
     *
     * 불변 객체를 이용해서 부작용을 없앨 수 있지만 그러면 인스턴스화한 다음에는 상태를 바꿀 수 없다. 따라서 불변 객체는 객체를 복사하지 않고 공유할 수 없으며,
     * 객체의 상태를 바꿀 수 없으므로 쓰레드 안정성을 보장한다.
     *
     * 이런 부작용없는 시스템 컴포넌트에서는 메소드가 서로 간섭하는 일이 없으므로 잠금을 사용하지 않고도 멀티코어 병렬성을 사용할 수 있다. 또한 프로그램의
     * 어떤 부분이 독립적인지 바로 이해할 수 있다. 이러한 부작용 없는 시스템의 개념은 함수형 프로그래밍에서 유래됐다.
     *
     *
     *
     *                              > 18.1.2 선언형 프로그래밍
     * 프로그램으로 시스템을 구현하는 방식은 크게 두 가지로 구분할 수 있다. 작업을 어떻게 수행할 것인지 집중하는 방법이 있다. 예를 들어 리스트에서 가장 비싼
     * 트랜잭션을 계산할 때 다음과 같은 일련의 명령을 실행할 것이다.
     *
     *  1. 리스트에서 트랜잭션을 가져와 가장 비싼 트랜잭션과 비교한다.
     *  2. 가져온 트랜잭션이 가장 비싼 트랜잭션보다 비싸다면 가져온 트랜잭션이 가장 비싼 트랜잭션이 된다.
     *  3. 리스트의 다음 트랜잭션으로 1~2를 반복한다.
     *
     * 이처럼 어떻게에 집중하는 프로그래밍 형식은 고전의 객체지향 프로그래밍에서 이용하는 방식이다. 때로는 이를 명령형 프로그래밍이라고 부르기도 하는데
     * 아래 코드에서 보여주는 것처럼 (할당, 조건문, 분기문, 루프 등) 명령어가 컴퓨터의 저수준 언어와 비슷하게 생겼기 때문이다.
     *
     *
     *      Transaction mostExpensive = transactions.get(0);
     *      if( mostExpensive == null ) {
     *          throw new IllegalArgumentException("Empty list of transactions");
     *          for( Transaction t : transactions.subList(1, transactions.size())) {
     *              if( t.getValue() > mostExpensive.getValue()) {
     *                  mostExpensive = t;
     *              }
     *          }
     *      }
     *
     * 어떻게가 아닌 '무엇을'에 집중하는 방식도 있다.
     * Optional<Transaction> mostExpensive = transaction.stream().max(comparing(Transaction::getValue));
     *
     * 질의문 구현 방법은 라이브러리가 결정한다. 이와 같은 구현 방식을 내부 반복이라고 한다. 질의문 자체로 문제를 어떠헥 푸는지 명확하게 보여준다는 것이
     * 내부 반복 프로그래밍의 장점이다.
     *
     * '어떻게'로 접근하는 방식을 선언형 프로그래밍이라고 부르기도 한다. 선언형 프로그래밍에서는 우리가 원하는 것이 무엇이고 시스템이 어떻게 그 목표를
     * 달성할 것인지에 대한 규칙을 정한다.
     *
     *
     *
     *                          > 18.1.3 왜 함수형 프로그래밍인가?
     * 함수형 프로그래밍은 선언형 프로그래밍을 따르는 대표적인 방식이며, 이전에 설명한 것처럼 부작용이 없는 계산을 지향한다. 선언형 프로그래밍과 부작용을 멀리
     * 한다는 두 가지 개념은 좀 더 쉽게 시스템을 구현하고 유지보수하는 데 도움을 준다.
     *
     * 3장에서 람다 표현식을 이용해서 보여준 것처럼 작업을 조합하거나 동작을 전달하는 등의 언어 기능은 선언형을 활용해서 자연스럽게 읽고 쓸 수 있는 코드를 구현
     * 하는데 많은 도움을 준다. 스트림으로는 여러 연산을 연결해서 복잡한 질의를 표현할 수 있었다. 이러한 기능은 함수형 프로그래밍의 특징을 고스란히 보여준다.
     * 이번에는 콤비네이터를 중심으로 함수형 프로그래밍의 특징을 좀 더 자세히 살펴볼 것이다.
     *
     *
     *
     *                          > 18.2 함수형 프로그래밍이란 무엇인가?
     *
     * int와 double을 인수로 받아서 double을 반환하는 메소드가 있는데 이 메소드는 자신이 호출된 횟수로 가변 변수를 갱신하는 부작용이 있다.
     * 함수형 프로그래밍에서 함수란 수학적인 함수와 같다. 자바와 같은 언어에서는 바로 수학적인 함수냐 아니냐가 메소드와 함수를 구분하는 핵심이다. 특히 인수가
     * 같다면 수학적 함수를 반복적으로 호출했을 때 항상 같은 결과가 반환된다. 하지만 Random.nextInt와 같은 메소드에서는 이런 규칙이 적용되지 않는데
     * 이와 관련된 내용은 참조 투명성을 살펴보면서 알아보자
     *
     * 함수형이라는 말은 '수학의 함수처럼 부작용이 없는'을 의미한다. 결과적으로 함수형 프로그래밍은 지금까지의 프로그래밍과 사뭇 다른 모습일 것이다. 함수형
     * 프로그래밍에서는 함수 그리고 if-then-else 등의 수학적 표현만 사용해야하는가?라는 질문에는 시스템의 다른 부분에 영향이 없다면 그렇다. 호출자에
     * 아무 영향을 미치지 않는다면 호출자는 내부적인 부작용을 파악하거나 신경 쓸 필요가 없다. 결론적으로 함수 그리고 if-then-else 등의 수학적인 표현만
     * 사용 하는 방식을 순수 함수형 프로그래밍이라고 하며 '시스템의 다른 부분에 영향을 미치지 않는다면 내부적으로 함수형이 아닌 기능도 사용'하는 방식을
     * 함수형 프로그래밍이라고 한다.
     *
     *
     *
     *                         > 18.2.1 함수형 자바
     * 실질적으로 자바로는 완벽한 순수 함수형 프로그래밍을 구현하기 어렵다. 예를 들어 자바의 I/O 모델 자체에는 부작용 메소드가 포함된다. (Scanner.nextLine을
     * 호출하면 파일의 행을 소비한다. 즉, Scanner.nextLine을 두번 호출하면 다른 결과가 반환될 가능성이 있다.) 하지만 시스템의 컴포넌트가 순서한 함수형인
     * 것처럼 동작하도록 코드를 구현할 수 있다. 자바에서는 순수 함수형이 아니라 함수형 프로그램을 구현할 것이다. 실제 부작용이 있지만 아무도 이를 보지 못하게 함으로써
     * 함수형을 달성할 수 있다. 부작용을 일으키지 않는 어떤 함수나 메소드가 있는데, 다만 진입할 떄 어떤 필ㄷ의 값을 증가시켰다가 빠져나올 때 필드의 값을
     * 돌려놓는다고 가정하자. 단일 쓰레드로 실행되면 부작용이 없으므로 함수형이라 볼 수 있곘지만 다중 쓰레드라면 이야기가 다르다. 메소드 바디를 잠금하면
     * 해결되겠지만 이러면 멀티코어 프로세서의 두 코어를 활용하는 의미가 퇴색된다.
     *
     * 함수나 메소드는 지역 변수만을 변경해야 함수형이라고 할 수 있다. 그리고 함수나 메소드에서 참조하는 객체가 있다면 그 객체는 불변 객체여야 한다. 즉, 객체의 모든
     * 필드가 final이어야 하고 모든 참조 필드는 불변 객체를 직접 참조해야 한다. 예외적으로 메소드 내에서 생성한 객체의 필드는 갱신할 수 있다. 단, 새로 생성한
     * 객체의 필드 갱신이 외부에 노출되지 않아야 하고 다음에 메소드를 다시 호출한 결과에 영향을 미치지 않아야 한다.
     *
     * 함수형이라고 말할 수 있으려면 이 외에도 다른 조건을 만족해야 한다. 함수형이라면 함수나 메소드가 어떤 예외도 일으키지 않아야 한다. 예외가 발생하면
     * 이전에 설명한 것처럼 블랙 박스 모델에서 return으로 결과를 반환할 수 없게 될 수 있기 때문이다. 이러한 제약은 함수형을 수학적으로 활용하는 데
     * 큰 걸림돌이 될 것이다. 수학적 함수는 주어진 수 값에 대응하는 하나의 결과를 반환한다. 실제 대부분의 수학 연산은 부분 함수로 활용된다. 어떤 입력값이
     * 있을 때는 이는 정확하게 하나의 결과로 도출된다. 하지만 입력값이 undefined라면 결과가 아예 나오지 않는다. 예를 들어 0으로 어떤 수를 나눈다거나
     * sqrt의 인자가 음수인 상황이 이에 해당한다. 자바에서는 이러한 상황을 '함수형'이라는 타이틀을 지키면서 어떻게 수행해야할까?
     *
     * Optional<T>를 사용하면 이 문제를 해결할 수 있다. double sqrt(double) 대신 Optional<Double> sqrt(double)을 이용하면 예외 없지도
     * 결과값으로 연산을 성공적으로 수행했는지 아니면 요청된 연산을 성공적으로 수행하지 못했는지 확인할 수 있다. 즉, 호출자는 메소드 호출 결과로 빈 Optional
     * 이 반환되는지 확인해야한다. 그러나 모든 코드가 Optional을 사용하도록 강제해야하는 것은 아니며 함수형 프로그래밍의 장단점을 실용적으로 고려하여
     * 다른 컴포넌트에 영향을 미치지 않도록 지역적으로 예외를 사용하는 방법을 고려할 수도 있다.
     *
     * 마지막으로 함수형에서는 비함수형 동작을 감출 수 있는 상황에서만 부작용을 포함하는 라이브러리 함수를 사용해야한다. (즉, 먼저 자료구조를 복사한다든다
     * 발생할 수 있는 예제를 적절하게 내부적으로 처러함으로써 자료구조의 변경을 호출자가 알 수 없도록 감춰야한다.
     *
     * 이와 같은 설명을 주석으로 표현하거나 마커 어노테이션으로 메소드를 정의할 수 있다. 마커 어노테이션을 사용했다면 Stream.map과 같은 병렬 스트림 처리
     * 연산에 전달할 떄 이와 같은 제약이 있는지 쉽게 확인할 수 있다. 우리가 만든 함수형 코드에서는 일종의 로그 파일로 디버깅 정볼ㄹ 출력하도록 구현하는 것이 좋다.
     * 물론 이처럼 디버깅 정보를 출력하는 것은 함수형의 규칙에 위배되지만 로그 출력을 제외하고는 함수형 프로그래밍의 장점을 문제없이 누릴 수 있다 .
     *
     *
     *                              > 18.2.2 참조 투명성
     * '부작용을 감춰야 한다'라는 제약은 참조 투명성 개념으로 귀결된다. 즉, 같은 인수로 함수를 호출했을 떄 항상 같은 결과를 반환한다면 참조적으로 투명한 함수라고
     * 표현한다.
     *
     *
     *
     *
     */
    }
}
