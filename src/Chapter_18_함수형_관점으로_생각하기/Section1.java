package Chapter_18_함수형_관점으로_생각하기;

import java.util.Arrays;

public class Section1 {
    public static void main(String[] args) {
    /**
     *                              > 18.1 시스템 구현과 유지보수
     * 지금까지 자바 8의 스트림을 사용하면 잠금(locking) 문제를 신경쓰지 않을 수 없다. 단, 자바 8의 스트림을 이용하려면 상태 없는 동작이어야 한다는 조건을
     * 만족해야한다. (즉, 스트림 처리 파이프 라인의 함수는 다른 누군가가 변수로 값을 바꿀 수 있는 상태에 있는 변수를 사용하지 않는다.). 또한 쉽게 유지
     * 보수 할 수 있으려면 어떠면 좋을까? 이는 결합성, 응집성으로 평가할 수 있다. 이런 점에서 함수형 프로그래밍이 제공하는 부작용 없음과 불변성이라는 개념이
     * 문제를 해결하는데 도움을 준다.
     *
     *
     *                              > 18.1.1 공유된 가변 데이터
     * 변수가 예상하지 못한 값을 갖는 이유는 결국 우리가 유지보수하는 시스템의 여러 메소드에서 공유된 가변 데이터 구조를 읽고 갱신하기 때문이다. 리스트를
     * 참조하는 여러 클래스가 있다고 가정하자 리스트의 소유자는 어느 클래스일까? 이들 중 하나의 클래스가 리스트를 갱신하면 어떻게 될까? 다른 클래스는 이를
     * 인지할까? 등등 공유 가변 데이터 구조를 사용하면 프로그램 전체에서 데이터 갱신 사실을 추적하기 어려워진다.
     *
     * 어떤 자료구조도 바꾸지 않는 시스템이 있다고 하자. 이러면 예상치 못하게 값이 바뀌는 경우가 드물것이다. 자신을 포함하는 클래스의 상태, 그리고 다른 객체의
     * 상태를 바꾸지 않으면 return을 통해서 자신의 결과를 반환하는 메소드를 순수 메소드, 부작용 없는 메소드라고 한다. 부작용이란 뭘까? 함수 내에 포함되지
     * 못한 기능을 부작용이라고 한다.
     *
     *      1. 자료구조를 고치거나 필드에 값을 할당(setter 메소드 같은 생성자 이외의 초기화 동작)
     *      2. 예외 발생
     *      3. 파일에 쓰기 등의 I/O 동작 수행
     *
     * 불변 객체를 이용해서 부작용을 없앨 수 있지만 그러면 인스턴스화한 다음에는 상태를 바꿀 수 없다. 따라서 불변 객체는 객체를 복사하지 않고 공유할 수 없으며,
     * 객체의 상태를 바꿀 수 없으므로 쓰레드 안정성을 보장한다.
     *
     * 이런 부작용없는 시스템 컴포넌트에서는 메소드가 서로 간섭하는 일이 없으므로 잠금을 사용하지 않고도 멀티코어 병렬성을 사용할 수 있다. 또한 프로그램의
     * 어떤 부분이 독립적인지 바로 이해할 수 있다. 이러한 부작용 없는 시스템의 개념은 함수형 프로그래밍에서 유래됐다.
     *
     *
     *
     *                              > 18.1.2 선언형 프로그래밍
     * 프로그램으로 시스템을 구현하는 방식은 크게 두 가지로 구분할 수 있다. 작업을 어떻게 수행할 것인지 집중하는 방법이 있다. 예를 들어 리스트에서 가장 비싼
     * 트랜잭션을 계산할 때 다음과 같은 일련의 명령을 실행할 것이다.
     *
     *  1. 리스트에서 트랜잭션을 가져와 가장 비싼 트랜잭션과 비교한다.
     *  2. 가져온 트랜잭션이 가장 비싼 트랜잭션보다 비싸다면 가져온 트랜잭션이 가장 비싼 트랜잭션이 된다.
     *  3. 리스트의 다음 트랜잭션으로 1~2를 반복한다.
     *
     * 이처럼 어떻게에 집중하는 프로그래밍 형식은 고전의 객체지향 프로그래밍에서 이용하는 방식이다. 때로는 이를 명령형 프로그래밍이라고 부르기도 하는데
     * 아래 코드에서 보여주는 것처럼 (할당, 조건문, 분기문, 루프 등) 명령어가 컴퓨터의 저수준 언어와 비슷하게 생겼기 때문이다.
     *
     *
     *      Transaction mostExpensive = transactions.get(0);
     *      if( mostExpensive == null ) {
     *          throw new IllegalArgumentException("Empty list of transactions");
     *          for( Transaction t : transactions.subList(1, transactions.size())) {
     *              if( t.getValue() > mostExpensive.getValue()) {
     *                  mostExpensive = t;
     *              }
     *          }
     *      }
     *
     * 어떻게가 아닌 '무엇을'에 집중하는 방식도 있다.
     * Optional<Transaction> mostExpensive = transaction.stream().max(comparing(Transaction::getValue));
     *
     * 질의문 구현 방법은 라이브러리가 결정한다. 이와 같은 구현 방식을 내부 반복이라고 한다. 질의문 자체로 문제를 어떠헥 푸는지 명확하게 보여준다는 것이
     * 내부 반복 프로그래밍의 장점이다.
     *
     * '어떻게'로 접근하는 방식을 선언형 프로그래밍이라고 부르기도 한다. 선언형 프로그래밍에서는 우리가 원하는 것이 무엇이고 시스템이 어떻게 그 목표를
     * 달성할 것인지에 대한 규칙을 정한다.
     *
     *
     *
     *                          > 18.1.3 왜 함수형 프로그래밍인가?
     * 함수형 프로그래밍은 선언형 프로그래밍을 따르는 대표적인 방식이며, 이전에 설명한 것처럼 부작용이 없는 계산을 지향한다. 선언형 프로그래밍과 부작용을 멀리
     * 한다는 두 가지 개념은 좀 더 쉽게 시스템을 구현하고 유지보수하는 데 도움을 준다.
     *
     * 3장에서 람다 표현식을 이용해서 보여준 것처럼 작업을 조합하거나 동작을 전달하는 등의 언어 기능은 선언형을 활용해서 자연스럽게 읽고 쓸 수 있는 코드를 구현
     * 하는데 많은 도움을 준다. 스트림으로는 여러 연산을 연결해서 복잡한 질의를 표현할 수 있었다. 이러한 기능은 함수형 프로그래밍의 특징을 고스란히 보여준다.
     * 이번에는 콤비네이터를 중심으로 함수형 프로그래밍의 특징을 좀 더 자세히 살펴볼 것이다.
     *
     *
     *
     *                          > 18.2 함수형 프로그래밍이란 무엇인가?
     *
     * int와 double을 인수로 받아서 double을 반환하는 메소드가 있는데 이 메소드는 자신이 호출된 횟수로 가변 변수를 갱신하는 부작용이 있다.
     * 함수형 프로그래밍에서 함수란 수학적인 함수와 같다. 자바와 같은 언어에서는 바로 수학적인 함수냐 아니냐가 메소드와 함수를 구분하는 핵심이다. 특히 인수가
     * 같다면 수학적 함수를 반복적으로 호출했을 때 항상 같은 결과가 반환된다. 하지만 Random.nextInt와 같은 메소드에서는 이런 규칙이 적용되지 않는데
     * 이와 관련된 내용은 참조 투명성을 살펴보면서 알아보자
     *
     * 함수형이라는 말은 '수학의 함수처럼 부작용이 없는'을 의미한다. 결과적으로 함수형 프로그래밍은 지금까지의 프로그래밍과 사뭇 다른 모습일 것이다. 함수형
     * 프로그래밍에서는 함수 그리고 if-then-else 등의 수학적 표현만 사용해야하는가?라는 질문에는 시스템의 다른 부분에 영향이 없다면 그렇다. 호출자에
     * 아무 영향을 미치지 않는다면 호출자는 내부적인 부작용을 파악하거나 신경 쓸 필요가 없다. 결론적으로 함수 그리고 if-then-else 등의 수학적인 표현만
     * 사용 하는 방식을 순수 함수형 프로그래밍이라고 하며 '시스템의 다른 부분에 영향을 미치지 않는다면 내부적으로 함수형이 아닌 기능도 사용'하는 방식을
     * 함수형 프로그래밍이라고 한다.
     *
     *
     *
     *                         > 18.2.1 함수형 자바
     * 실질적으로 자바로는 완벽한 순수 함수형 프로그래밍을 구현하기 어렵다. 예를 들어 자바의 I/O 모델 자체에는 부작용 메소드가 포함된다. (Scanner.nextLine을
     * 호출하면 파일의 행을 소비한다. 즉, Scanner.nextLine을 두번 호출하면 다른 결과가 반환될 가능성이 있다.) 하지만 시스템의 컴포넌트가 순서한 함수형인
     * 것처럼 동작하도록 코드를 구현할 수 있다. 자바에서는 순수 함수형이 아니라 함수형 프로그램을 구현할 것이다. 실제 부작용이 있지만 아무도 이를 보지 못하게 함으로써
     * 함수형을 달성할 수 있다. 부작용을 일으키지 않는 어떤 함수나 메소드가 있는데, 다만 진입할 떄 어떤 필ㄷ의 값을 증가시켰다가 빠져나올 때 필드의 값을
     * 돌려놓는다고 가정하자. 단일 쓰레드로 실행되면 부작용이 없으므로 함수형이라 볼 수 있곘지만 다중 쓰레드라면 이야기가 다르다. 메소드 바디를 잠금하면
     * 해결되겠지만 이러면 멀티코어 프로세서의 두 코어를 활용하는 의미가 퇴색된다.
     *
     * 함수나 메소드는 지역 변수만을 변경해야 함수형이라고 할 수 있다. 그리고 함수나 메소드에서 참조하는 객체가 있다면 그 객체는 불변 객체여야 한다. 즉, 객체의 모든
     * 필드가 final이어야 하고 모든 참조 필드는 불변 객체를 직접 참조해야 한다. 예외적으로 메소드 내에서 생성한 객체의 필드는 갱신할 수 있다. 단, 새로 생성한
     * 객체의 필드 갱신이 외부에 노출되지 않아야 하고 다음에 메소드를 다시 호출한 결과에 영향을 미치지 않아야 한다.
     *
     * 함수형이라고 말할 수 있으려면 이 외에도 다른 조건을 만족해야 한다. 함수형이라면 함수나 메소드가 어떤 예외도 일으키지 않아야 한다. 예외가 발생하면
     * 이전에 설명한 것처럼 블랙 박스 모델에서 return으로 결과를 반환할 수 없게 될 수 있기 때문이다. 이러한 제약은 함수형을 수학적으로 활용하는 데
     * 큰 걸림돌이 될 것이다. 수학적 함수는 주어진 수 값에 대응하는 하나의 결과를 반환한다. 실제 대부분의 수학 연산은 부분 함수로 활용된다. 어떤 입력값이
     * 있을 때는 이는 정확하게 하나의 결과로 도출된다. 하지만 입력값이 undefined라면 결과가 아예 나오지 않는다. 예를 들어 0으로 어떤 수를 나눈다거나
     * sqrt의 인자가 음수인 상황이 이에 해당한다. 자바에서는 이러한 상황을 '함수형'이라는 타이틀을 지키면서 어떻게 수행해야할까?
     *
     * Optional<T>를 사용하면 이 문제를 해결할 수 있다. double sqrt(double) 대신 Optional<Double> sqrt(double)을 이용하면 예외 없지도
     * 결과값으로 연산을 성공적으로 수행했는지 아니면 요청된 연산을 성공적으로 수행하지 못했는지 확인할 수 있다. 즉, 호출자는 메소드 호출 결과로 빈 Optional
     * 이 반환되는지 확인해야한다. 그러나 모든 코드가 Optional을 사용하도록 강제해야하는 것은 아니며 함수형 프로그래밍의 장단점을 실용적으로 고려하여
     * 다른 컴포넌트에 영향을 미치지 않도록 지역적으로 예외를 사용하는 방법을 고려할 수도 있다.
     *
     * 마지막으로 함수형에서는 비함수형 동작을 감출 수 있는 상황에서만 부작용을 포함하는 라이브러리 함수를 사용해야한다. (즉, 먼저 자료구조를 복사한다든다
     * 발생할 수 있는 예제를 적절하게 내부적으로 처러함으로써 자료구조의 변경을 호출자가 알 수 없도록 감춰야한다.
     *
     * 이와 같은 설명을 주석으로 표현하거나 마커 어노테이션으로 메소드를 정의할 수 있다. 마커 어노테이션을 사용했다면 Stream.map과 같은 병렬 스트림 처리
     * 연산에 전달할 떄 이와 같은 제약이 있는지 쉽게 확인할 수 있다. 우리가 만든 함수형 코드에서는 일종의 로그 파일로 디버깅 정볼ㄹ 출력하도록 구현하는 것이 좋다.
     * 물론 이처럼 디버깅 정보를 출력하는 것은 함수형의 규칙에 위배되지만 로그 출력을 제외하고는 함수형 프로그래밍의 장점을 문제없이 누릴 수 있다 .
     *
     *
     *                              > 18.2.2 참조 투명성
     * '부작용을 감춰야 한다'라는 제약은 참조 투명성 개념으로 귀결된다. 즉, 같은 인수로 함수를 호출했을 떄 항상 같은 결과를 반환한다면 참조적으로 투명한 함수라고
     * 표현한다. 예를 들어 "raoul".replace('r','R')이라는 코드는 항상 같은 결과가 나오므로 String.replace는 참조적으로 투명하다.
     * 다시 말해, 함수는 어떤 입력이 주어졌을 때 언제, 어디서 호출하든 같은 결과를 반환해야한다. 따라서 Random.nextInt는 함수형이 될 수 없다.
     * 마찬가지라 자바의 Scanner 객체로 사용자의 키보드 입력을 받는다면 참조 투명성을 위배한다. nextLine 메소드를 호출했을 때 매번 다른 결과가 나올 수 있기
     * 때문이다. 하지만 두 개의 final int 변수를 더하는 연산에서는 두 변수를 바꿀 수 없으므로 이 연산은 항상 같은 결과를 생성한다.
     * 참조 투명성은 프로그램 이해에 큰 도움을 준다. 또한 참조 투명성은 비싸거나 오랜 시간이 걸리는 연산을 기어화(memorizeation) 또는 캐싱(cachig)을
     * 통해 다시 계산하지 않고 저장하는 최적화 기능도 제공한다.
     *
     * 자바에는 참조 투명성과 관련한 작은 문제가 있다. List를 반환하는 메소드는 두 번 호출한다고 가정하자. 두 번의 홏ㄹ 결과르 같은 요소를 포함하지만 서로 다른 메모리
     * 공간에 생성된 리스트를 참조할 것이다. 결과 리스트가 가변 객체라면 (반환된 두 리스트가 같은 객체라 할 수 없으므로) 리스트를 반환하는 메소드는 참조적으로
     * 투명한 메소드가 아니라는 결론이 나온다. 결과 리스트를 (불변의) 순수 값으로 사용할 것이라면 두 리스트가 같은 객체라고 볼 수 있으므로 리스트 생성 함수는
     * 참조적으로 투명한 것으로 간주할 수 있다. 일반적으로 함수 코드에서는 이런 함수를 참조적으로 투명한 것으로 간주한다.
     *
     *
     *
     *                              > 18.2.3 객체지향 프로그래밍과 함수형 프로그래밍
     * 먼저 함수형 프로그래밍과 기존의 익스트림 객체지향 프로그래밍을 비교하자. 사실 자바 8은 함수형 프로그래밍을 익스트림 객체지향 프로그래밍의 일종으로
     * 간주한다. 대부분의 자바 프로그래머는 무의식적으로 함수형 프로그래밍의 일부 기능과 익스트림 객체지향 프로그래밍의 일부 기능을 사용하게 될 것이다.
     * 프로그래밍 형식을 스펙트럼으로 표현하자면 스펙트럼의 한 쪽 끝에는 모든 것을 객체로 간주하고 프로그램이 객체의 필드를 갱신하고, 메소드를 호출하고, 관련
     * 객체를 갱신하는 방식으로 동작하는 익스트림 객체지향 방식이 위치한다. 스펙트럼의 반대쪽 끝에는 참조적 투명성을 중시하는, 즉 변화를 허용하지 않는 함수형 프로그래밍
     * 형식이 위치한다. 실제로 자바 프로그래머는 이 두 가지 프로그래밍 형식을 혼합한다. 예를 들어 Iterator로 가변 내부 상태를 포함하는 자료구조를 탐색하면서 함수형
     * 방식으로 자료구조에 들어 있는 값의 합계를 계산할 수 있다.
     *
     *
     *
     *                              > 18.2.4 함수형 실전 연습
     * 함수형을 처음 접하는 학생들에게 종종 제공되는 간단한 예를 보자. {1,4,9}처럼 List<Integer>가 주어졌을 때 이것의 모든 서브 집합의 멤버로 구성된
     * List<List<Integer>>를 만드는 프로그램을 만든다고 가정하자. 예를 들어 {1,4,9}의 서브 집합은 {1,4,9}, {1,4}, {1,9}, {4,9}, {1}, {4},
     * {9}, {}다.
     * 빈 집합을 포함하여 8개의 서브 집합이 존재한다. 각 서브 집합은 List<Integer> 형식으로 이뤄져 있으므로 최종 정답 형식은 List<List<Integer>>다.
     *
     *
     *              Chapter_18_함수형_관점으로_생각하기/FunctionalExam.java답
     *
     */
        System.out.println(FunctionalExam.subSet(Arrays.asList(1,4,9)));;
    /**
     *
     *  입력으로 {1,4,9}를 제공하면 예상한 결과를 얻을 수 있다. 또한 insertAll, concat에서 항수형 메소드의 구현이 없다. 또한 subsets도
     *  기존의 구조를 갱신하지 않으므로 함수형이다. (수학적 귀납법의 인수처럼 처리된다.) 또한 각 메소드는 새로운 List를 만들어서 Integer 객체가
     *  불변이라는 사실을 이용했다.
     *
     *
     *                      > 18.3 재귀와 반복
     *  순수 함수형 프로그래밍 언어에서는 while, for과 같은 반복문을 포함하지 않는다.  왜 그럴까? 이러한 반복문 떄문에 변화가 자연스럽게 코드에 스며들 수
     *  있기 떄문이다. 예를 들어 while 루프의 조건문을 갱싱해야 할 때가 있다. 그렇지 ㅇ랂으면 루프가 아예 실행되지 않거나 무한으로 반복될 수 있다.
     *  이외의 일반적인 상황에서는 루프를 안전하게 사용할 수 있다. 함수형 스타일에서는 다른 누군가가 변화를 알아차리지만 못한다면 아무 상관이 없다고 했다.
     *  즉 지역 변수는 자유롭게 갱신할 수 있다. 다음은 자바의 Iterator로 for(Apple a: apples) {}라는 for-each를 표현한 코드이다.
     *
     *
     *          Iterator<Apple> it = apples.iterator();
     *          while(it.hasNext()) {
     *              Apple apple = it.next();
     *              //생략
     *          }
     *
     *  위 코드에서는 호출자는 변화를 확인할 수 없으므로 아무 문제가 없다. (즉, next로 Iterator의 상태를 변환했고, while 바디 내부에서 apple
     *  변수에 할당하는 동작을 할 수 있다.) 하지만 다음 코드처럼 for-each를 사용하면 검색 알고리즘은 문제가 될 수 있다.
     *
     *
     *          public void searchForGold(List<String> l, Stats, stats) {
     *              for(String s : l) {
     *                  if("gold".equals(s)){
     *                      stats.incrementFor("gold");
     *                  }
     *              }
     *          }
     *
     *  루프의 바디에서 함수형과 상충하는 부작용이 발생한다. 즉, 루프 내부에서 프로그램의 다른 부분과 공유되는 stats 객체의 상태를 변화시킨다.
     *  그럼 어떻게 프로그램을 구현할까? 이론적으로 반복을 이용하는 모든 프로그램은 재귀로도 구현할 수 있는데 재귀를 이용하면 변화가 일어나지 않는다.
     *  재귀를 이용하면 루프 단계마다 갱신되는 반복 변수를 제거할 수 있다. 다음은 팩토리얼 함수로, 반복과 재귀 방식으로 해결할 수 있는 고전적 문제이다.
     *  여기서 입력은 1보다 크다고 가정한다.
     *
     * //반복 방식
     *          static int factorialIterative(Int n) {
     *              int r = 1;
     *              for ( int i = 1; i <= n; i++) {
     *                   r *= i;
     *              }
     *              return r;
     *          }
     *
     *
     * //재귀 방식
     *
     *          static long factorialRecursive(long n) {
     *              return n == 1 ? 1 : n * factorialRecursive(n-1);
     *          }
     *
     * 첫 번째 예제는 일반적인 루프를 사용한 코드로 매 반복마다 변수 r과 i가 갱신된다. 두 번째 예제는 재귀 방식 코드로 더 수학적인 형식으로 문제를 해결한다.
     *
     *
     * //스트림 팩토리얼
     *
     *          static long factorialStream(long n) {
     *              return LongStream.rangeClosed(1,n).reduce(1, (long a, long b) -> a * b);
     *          }
     *
     * 효율성 측면을 살펴보자. 일반적으로 반복보다 재귀가 더 리소스를 많이 잡아 먹는다. factorialRecursive를 호출할 때마다 호출 스택에 각 호출시 생성되는
     * 정보를 저장할 새로운 스택 프레임이 만들어진다. 즉, 재귀 팩토리얼의 입력값에 비례해서 메모리 사용량이 증가한다. 따라서 큰 입력값을 사용하면 StackOverFlow가
     * 발생한다.
     *
     * 그러면 재귀는 지양해야하는가? 또 무조건 그렇지 않다. 꼬리 호출 최적화(tail-call optimization)라는 해결책을 제시한다.
     *
     *
     *          static long factorialTailRecursive(long n) {
     *              return factorialHelper(1,n);
     *          }
     *          static long factorialHelper(long acc, long n) {
     *              return n == 1 ? acc : factorialHelper(acc * n, n - 1);
     *          }
     *  factorialHelper에서 재귀 호출이 가장 마지막에서 이뤄지므로 꼬리 재귀이다. 이전의 재귀는 결과 값이 곱셈의 결과 값이다. 중간 값을 각각의 스택 프레임으로
     *  저장해야하는 일반 재귀와 달리 꼬리 재귀는 컴파일러가 하나의 스택 프레임을 재활용할 가능성이 생긴다. 그러나! 안타깝게도 자바는 이러한 최적화를 제공하지는 않는다.
     *  그럼에도 고전적인 재귀보다 여러 컴파일러 최적화 여지를 남겨둘 수 있는 꼬리 재귀가 더 좋다. 스칼라, 그루비의 최신 JVM 언어는 이와 같은 재귀를 반복으로 변환하는 최적화를
     *  제공한다.
     */
    }
}
