package Chapter_13_디폴트_메소드;

public class Section1 {
    /**
     *  전통적인 자바에서 인터페이스와 관련된 메소드는 한 몸처럼 구성된다. 인터페이스를 구현하는 클래스는 인터페이스에서 정의하는 모든 메소드 구현을 제공하거나
     *  아니면 슈퍼 클래스의 구현을 상속받아야한다.
     *  하지만 자바 8부터는 새로운 기능을 제공한다. 자바 8에서는 기본 구현을 포함하는 인터페이스를 정의하는 두 가지 방법을 제공한다. 첫 번쨰 인터페이스
     *  내부에 정적 메소드(static method)를 사용하는 것이다. 두 번째는 인터페이스의 기본 구현을 제공할 수 있도록 디폴트 메소드(default method)
     *  기능을 제공하는 것이다. 즉, 자바 8에서는 메소드 구현을 포함하는 인터페이스를 정의할 수 있다. 결과적으로 기존 인터페이스를 구현하는 클래스는 자동으로
     *  인터페이스에 추가된 새로운 메소드의 디폴트 메소드를 상속받게 된다. 이렇게 하면 기존의 코드 구현을 바꾸지 않도록 할 수 있다.
     *
     *  예를 들어 List 인터페이스의 sort와 Collection 인터페이스의 stream을 보면 알 수 있다.
     *
     * >> List
     *      default void sort(Comparator<? super E> c){
     *          Collections.sort(this, c);
     *      }
     *
     * >> Collection
     *      default Stream<E> stream() {
     *          return StreamSupport.stream(Spliterator(),false);
     *      }
     *  이렇게 되면 추상클래스와 유사해보인다.
     *
     *
     *          {
     *                      > 바이너리 호환성, 소스 호환성, 동작 호환성
     *              자바 프로그램을 바꾸는 것과 관련된 호환성 문제는 크게 바이너리 호환성, 소스 호환성, 동작 호환성 세 가지로 분류할 수 있다.
     *              1. 뭔가를 바꾼 이후에도 에러 없이 기존 바이너리가 실행될 수 있는 상황을 바이너리 호환성이라고 한다. (인증, 준비, 해석 등의 과정이
     *              포함된다.)
     *
     *              2. 코드를 고쳐도 기존 프로그램을 성공적으로 재컴파일할 수 있는 것을 소스 호환성이라고 한다.
     *
     *              3. 코드를 바꾼 다음에도 같은 입력에 대해서 같은 동작을 실행하는 것을 동작 호환성이라고 한다.
     *
     *          }
     *
     *              > 13.2 디폴트 메소드란 무엇인가?
     *   인터페이스는 자신을 구현하는 클래스에서 메소드를 구현하지 않을 수 있는 메소드 시그니처를 제공한다. 디폴트 메소드는 인터페이스를 구현하는 클래스에서
     *   구현하지 않는 메소드를 인터페이스 자체에서 기본으로 제공한다. 디폴트 메소드 여부는 어떻게 알 수 있을까? 디폴트 메소드는 default 키워드로 시작하며
     *   다른 클래스에 선언된 메소드처럼 메소드 바디가 있다. 디폴트 메소드는 인터페이스 변경시 소스 호환성을 보장한다.
     *
     *
     *          {
     *                      > 추상클래스와 자바 8의 인터페이스
     *              1. 추상 클래스는 상속, 인터페이스는 구현이기 때문에 다중 상속, 구현에서 차이가 난다.
     *              2. 추상클래스는 필드를 가질 수 있지만 인터페이스는 그렇지 않다.
     *          }
     *
     *
     *
     *
     *              > 13.3 디폴트 메소드 활용 패턴
     *   디폴트 메소드를 사용하면 라이브러리를 바꿔도 호환성을 유지할 수 있다. 우리가 만드는 인터페이스에도 디폴트 메소드를 추가할 수 있다. 이를 이용하는
     *   선택형 메소드, 다중 상속을 알아보자
     *
     *
     *              > 13.3.1 선택형 메소드
     *   인터페이스를 구현하는 클래스에서 메소드 내용이 비어있는 경우를 본 적이 있을 것이다. 이는 인터페이스에서 정의하고 사용하지 않아서 메소드를 빈 상태로
     *   두기 떄문이다. 그러나 이런 경우 디폴트 메소드로 만들면 이런 경우를 줄일 수 있다.
     *
     *              >13.3.2 동작 다중 상속
     *   디폴트 메소드를 사용하면 기존에 불가능했던 동작 다중 상속 기능을 구현할 수 있다. 자바에서는 클래스의 필드 중복 문제로 하나만 상속할 수 있지만
     *   인터페이스는 여러 개를 구현할 수 있다.
     *
     *          {
     *                      > 옳지 못한 상속
     *
     *              상속으로 코드 재사용 문제를 모두 해결할 수 있는 것은 아니다. 예를 들어 한 개의 메소드를 재사용하려고 쓸모 없는 필드가 있는
     *              클래스를 상속받는 것은 난해한 일이다. 이런 때는 델리게이션, 즉 멤버 변수를 이용해서 클래스에서 필요한 메소드를 직접 호출하는
     *              메소드를 작성하는 것이 좋다. 종종 final 선언이 붙은 클래스를 볼 수 있는데 이는 상속이 불가능하다. 이렇게 상속을 막을 수도 있다.
     *          }
     *
     *    만약 같은 디폴트 메소드 시그니쳐를 포함하는 두 인터페이스를 한 번에 구현하면 어떻게 될까?
     *
     *
     *              >13.4 해석 규칙
     *
     *    위와 같은 상황에서 메소드를 콜하면 어떤 메소드가 실행될까?
     */
    interface A {
        default void hello(){
            System.out.println("HELLO A");
        }
    }
    interface B extends A {
        default void hello() {
            System.out.println("HELLO B");
        }
    }
    class C implements B, A {
        public void hello(){
            new C().hello();
        }
    }
    /**
     * 이러한 경우 세 가지 규칙이 있다.
     * 1. 클래스가 우선순위를 갖는다. 클래스나 슈퍼클래스에서 정의한 메소드가 디폴트 메소드보다 우선이다.
     * 2. 1번 이외에 서브 인터페이스가 우선순위를 갖는다. 상속 관계를 갖는 인터페이스에서 같은 시그니쳐를 갖는 메소드를 정의할 때는 서브 인터페이스가
     * 우선순위가 높다.
     * 3. 여전히 디폴트 메소드 우선순위가 정해지지 않았다면 여러 인터페이스를 상속받는 클래스가 명시적으로 디폴트 메소드를 오버라이드하고 호출해야한다.
     *
     *
     *          > 13.4.4 다이아몬드 상속 문제
     *    public interface A {
     *        default void hello(){
     *            System.out.println("A");
     *        }
     *    }
     *
     *    public interface B extends A {
     *
     *    }
     *
     *    public interface C extends A {
     *
     *    }
     *
     *    class D implements B, C {
     *        public static void main(String... args){
     *            new C().hello(); //이러면 뭐가 출력될까?
     *        }
     *    }
     *
     *    이러한 다이아몬드 상속이 벌어지면 A의 hello를 선택한다. 만약 B에서 오버라이드했다면 B의 메소드가 호출된다.
     *    추가적으로 B,C에서 둘다 오버라이드 했다면 class D에서 선택해서 오버라이드를 해야 컴파일 에러를 피할 수 있다.
     */
}
