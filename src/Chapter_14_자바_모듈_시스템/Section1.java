package Chapter_14_자바_모듈_시스템;

public class Section1 {
    /**
     *
     *   쉬운 소프트웨어를 만드는 데 도움을 주는 관심사 분리와 정보 은닉을 살펴보자.
     *
     *          > 14.1.1 관심사 분리(SoC, Separation of Concerns)
     *   관심사 분리는 컴퓨터 프로그램을 고유의 기능으로 나누는 동작을 권장하는 원칙이다. 각 기능을 모듈이라는 각각의 부분, 서로 겹치지 않는 코드 그룹으로
     *   분리할 수 있다. 다시 말해 클래스를 그룹화한 모듈을 이용해 애플리케이션의 클래스 간의 관계를 시각적으로 보여줄 수 있다. 자바 9 모듈은 클래스가
     *   어떤 다른 클래스를 볼 수 있는지를 컴파일 타임에 정교하게 제어할 수 있다.
     *
     *   SoC 원칙은 모델, 뷰, 컨트롤러 같은 아키텍쳐 관점 그리고 복구 기법을 비즈니스 로직과 분리하는 등의 하위 수준 접근 등의 상황에 유용하다. SoC 원칙은
     *   아래와 같은 장점을 제공한다.
     *
     *      1. 개별 기능을 따로 작업할 수 있으므로 팀이 쉽게 협업할 수 있다.
     *      2. 개별 부분을 재사용할 수 있다.
     *      3. 전체 시스템을 쉽게 유지보수할 수 있다.
     *
     *
     *          > 14.1.2 정보 은닉
     *   정보 은닉은 세부 구현을 숨기도록 장려하는 원칙이다. 세부 구현을 숨김으로써 프로그램의 어떤 부분을 바꿨을 때 다른 부분까지 영향을 미칠 가능성을
     *   줄일 수 있다. 즉, 코드를 관리하고 보호하는데 유용한 원칙이다. 캡슐화는 특정 코드 조각이 애플리케이션의 다른 부분과 고립되어 있음을 의미한다.
     *   캡슐화된 코드의 내부적인 변화가 의도치 않게 외부에 영향을 미칠 가능성이 줄어든다. 자바에서 클래스 내의 컴포넌트에 적절하게 private 키워드를 사용
     *   했는지를 기준으로 컴파일러를 이용해서 캡슐화를 확인할 수 있다.
     *
     *
     *          > 14.2 자바 모듈 시스템을 설계한 이유
     *
     *          > 14.2.1 모듈화의 한계
     *   자바 9 이전까지는 모듈화된 소프트웨어 프로젝트를 만드는데 한계가 있었다. 자바는 클래스, 패키지, JAR 세 가지 수준의 코드 그룹화를 제공한다.
     *   클래스와 관련해 자바는 접근 제한자와 캡슐화를 지원했다. 하지만 패키지와 JAR 수준에서는 캡슐화를 거의 지원하지 않았다.
     *
     *          > 제한된 가시성 제어
     *   많은 애플리케이션은 다양한 클래스 그룹을 정의한 여러 패키지가 있는데 패키지의 가시성 제어 기능은 유명무실한 수준이다. 한 패키지의 클래스와
     *   인터페이스를 다른 패키지로 공개하려면 public으로 이들을 선언해야한다. 결과적으로 이들 클래스와 인터페이스는 모두에게 공개된다. 특히 기본 구현을
     *   제공하는 의미로 impl이라는 문자열을 가진 패키지에서 이런 문제가 두드러진다. 이런 상황에서 보통 패키지 내부의 접근자가 public이므로 사용자가
     *   이 내부 구현을 마음대로 사용할 수 있다. 내부적으로 사용할 목적으로 만든 구현을 다른 프로그래머가 임시적으로 사용해서 정착해버릴 수 있으므로
     *   결국 기존의 애플리케이션을 망가뜨리지 않고 라이브러리 코드를 바꾸기 어려워진다.
     *
     *          > 클래스 경로
     *   자바는 클래스를 모두 컴파일한 다음 보통 한 개의 JAR에 넣고 클래스 경로에 이 JAR을 추가해 사용할 수 있다. 그러면 JVM이 동적으로 클래스 경로에
     *   정의된 클래스를 필요할 때 읽는다.
     *   첫째, 클래스 경로에는 같은 클래스를 구분하는 버전 개념이 없다. 예를 들어 파싱 라이브러리의 JSONParser 클래스를 지정할 때 하나만 있을지 버전이 다른
     *   게 두 개가 있을지 장담할 수 없으므로 이런 상황에서 문제가 발생한다.
     *   둘째, 클래스 경로는 명시적인 의존성을 지원하지 않는다. 각각의 JAR 안에 있는 모든 클래스는 classes라는 한 곳으로 합쳐진다. 즉, JAR가 다른 JAR에
     *   포함된 클래스 집합을 사용하라고 명시적으로 의존성을 정의하는 기능을 제공하지 않는다. 이 상황에서는 클래스 경로 때문에 어떤 일이 일어나는지 파악하기
     *   어렵게 되고 "빠진 것이 있는지", "충돌이 있는지" 장담할 수 없다.
     *
     *
     *          > 14.2.2 비대해진 JDK
     *   시간이 지나면서 JDK도 비대해졌다. 이는 군더더기가 생겼다는 의미가 된다. 이 문제를 생태계 전반에서 어떻게 피할 수 있을까? 자바 8 에서는 컴팩트 프로파일
     *   이라는 기법을 제시했다. 하지만 이 역시 한계가 있다. 나자의 낮은 캡슐화 때문에 내부 API가 외부로 공개되었다. 이러한 문제들 때문에 JDK 자체도 모듈화
     *   할 수 있는 자바 모듈 시스템 설계의 필요성이 제기되었다. 즉 JDK에서 필요한 부분만 골라서 사용하고, 클래스 경로를 쉬벡 유추할 수 있으며,
     *   플랫폼을 진화시킬 강력한 아키텍쳐가 필요했다.
     *
     *
     *          > 14.3 자바 모듈
     *    자바 8은 모듈이라는 새로운 자바 프로그램 구조 단위를 제공한다. 모듈은 module이라는 새 키워드에 이름과 바디를 추가해서 정의한다. 모듈 디스크립터
     *    는 module-info.java라는 특별한 파일에 저장된다.
     *    모듈 디스크립터는 보통 패키지와 같은 폴더에 위치하며 한 개 이상의 패키지를 서술하고 캡슐화할 수 있지만 단순한 상황에서는 이들 패키지 중 한 개만 외부로
     *    노출시킨다.
     *
     *
     *          > 14.4 모듈시스템 사용하기
     *    예를 들어 비용관리를 하는 예제를 만들어보자. 구현 사항은 아래와 같다.
     *
     *      1. 파일, URL에서 비용 목록을 읽는다.
     *      2. 비용의 문자열 표현을 파싱한다.
     *      3. 통계를 계산한다.
     *      4. 유용한 요약 정보를 표시한다.
     *      5. 각 태스크의 시작, 마무리 지점을 제공한다.
     *
     *    기능을 구현하기 위해서 클래스, 인터페이스를 정의해야한다. Reader 인터페이스는 소스에서 얻어온 직렬화된 지출을 읽는다. 파일, URL에 따라
     *    HttpReader, FileReader로 구현해야한다. 또한 JSON 객체를 자바 애플리케이션에 사용할 수 있는 도메인 Expense로 재구성할 Parser 인터페이스
     *    도 필요하다. 마지막으로 Expense 객체 목록으로 통계를 계산하고 SummaryStatistics 객체를 반환하는 SummaryCalculator가 필요하다.
     *
     *    이를 모듈화하는 것도 필요하다. 관심사에 따라서 분류한다.
     *
     *      1. 데이터를 읽음(Reader, HttpReader, FileReader)
     *      2. 파싱(Parser, JSONParser, ExpenseJSON-Parser)
     *      3. 도메인 객체를 구체화(Expense)
     *      4. 통계 계산, 반환(SummaryCalculator, SummaryStatistics)
     *      5. 다양한 기능을 분리 조정(ExpsensesApplication)
     *
     */
}
