package Chapter_01_자바에서의_변화;

public class Section1 {
    /**
     *      > 서문
     *
     * 자바 8로 넘어오면서 특히 멀티 코어를 이용한 병렬 처리에 대한 접근이 쉬워졌다. 자바8로 넘어오면서 생긴 변화를 요약하면 아래와 같다.
     *  1. 스트림 API
     *  2. 메서드에 코드를 전달하는 기법
     *  3. 인터페이스의 디폴트 메소드
     *
     *  스트림 API를 사용하면 에러를 자주 일으키며 멀티코어를 사용하는 것보다 비용이 비싼 Synchronized를 사용하지 않아도 된다.
     *  조금 다른 관점으로 보면 스트림 API 덕에 메소드에 코드를 전달하는 기법(메소드 참조와 람다), 인터페이스의 디폴트가 존재할 수 있다.
     *  -> 함수형 프로그래밍(Functional-style Programming)
     *
     *  이와 같은 자바8은 아래의 세 가지 프로그래밍 개념을 바탕으로 설계되었다.
     *
     *  1. 스트림 처리
     *  스트림이란 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임이다. 이는 자동차 생성 공장으로 비유할 수 있다. 공장은 여러 자동차로
     *  구성된 스트림을 처리하는데, 각각의 작업장에서는 자동차를 받아서 수리한 다음에 다음 작업장에서 다른 작업을 할 수 있도록 넘겨준다.
     *  이와 같이 java.util.stream 패키지에 추가된 스트림 API는 Stream<T>에서 T 형식으로 구성된 일련의 항목을 가지고 파이프 라인을
     *  만드는데 필요한 많은 메소드를 제공한다. 즉, 기존에는 한 번에 한 항목으로 처리했지만 자바 8에서는 하려는 작업을 고수준으로 추상화하여
     *  일련의 스트림으로 만들어 처리할 수 있다는 것이다. 또한 스트림 파이프라인을 통해서 입력 부분을 여러 CPU 코어에 쉽게 할당할 수 있다는
     *  부가적인 이득도 얻을 수 있다. 이는 쓰레드를 사용하지 않고 공짜로 병렬성을 얻을 수 있다는 이득이 있다.
     *
     *  2. 동작 파라미터화로 메소드에 코드 전달하기
     *  자바 8에서 두 번째 프로그램 개념은 코드 일부를 API로 전달하는 기능이다. 예를 들어 유닉스에서 sort 명령에 파라미터를 추가하고 싶을 수 있다.
     *  sort에 파라미터를 제공해서 다양한 정렬을 수행할 수는 있지만 동작은 정해져 있다.
     *  여기서 우리는 지정하는 순서대로 자료를 정리하도록 sort 메소드에 명령을 내려야 한다. 이때 비교하는 방법을 메소드로 구현해야한다. 자바 8 이전에는
     *  메소드를 다른 메소드로 전달할 방법이 없었다. 물론 객체를 만들어 sort에 넘겨주는 방법이 있을 수 있으나 이는 복잡하며 재활용성이 좋지 않다.
     *
     *          ex) Collections.sort(inventory, new Comparator<Apple>(){
     *              public int compare(Apple a1, Apple a2){
     *                  return a1.getWeight().compareTo(a2.getWeight());
     *              }
     *          });
     *
     *  자바 8에서는 메소드를 다른 메소드의 인수로 넘겨주는 기능을 제공한다. 이러한 기능을 이론적으로 동작 파라미터화(behavior paramerterization)
     *  이라고 부른다. 이는 스트림 API 연산의 동작을 파라미터화할 수 있는 코드를 전달한다는 사상에 기초한다. 이를 이용하면 아래와 같다.
     *
     *         ex) inventory.sort(comparing(Apple::getWeight));
     *
     *  3. 병령성과 공유 가변 데이터
     *  세 번째는 '병렬성을 공짜로 얻는다.'에서 시작된다. 물론 공짜로 병렬성을 얻는 대신 코드의 동작 방식을 변경해야 한다. 보통 다른 코드와 동시에 실행
     *  하더라도 안전하게 실행할 수 있는 코드를 만들려면 공유된 가변 데이터(shared mutable data)에 접근하지 않아야 한다. 이러한 함수를 순수(Prune) 함수,
     *  부작용 없는(side-effect free) 함수, 상태 없는(stateless) 함수라고 부른다. 공유되지 않는 가변 데이터, 메소드, 함수 코드를 다른 메소드로
     *  전달하는 두 가지 기능은 함수형 패러다임의 핵심적인 사항이다.
     *
     *
     *
     *      > 1.3 자바에서 함수
     *  프로그래밍 언어에서 함수는 메소드, 특히 정적 메소드와 같은 의미로 사용된다. 자바의 함수는 이에 더해 수학적인 함수처럼 사용되며 부작용을 일으키지 않는
     *  함수를 의미한다. 프로그래밍 언어의 핵심을 값을 바꾸는 것이다. 전통적인 프로그래밍언어에서는 이를 일급 값(일급 시민)이라고 부른다. 자바 프로그래밍
     *  언어의 다양한 구조체(메소드, 클래스 같은)가 값의 구조를 표현하는데 도움이 될 수는 있지만 런타임 중 이러한 모든 구조체를 자유롭게 전달할 수는 없다.
     *  그래서 자바에서 메소드, 클래스는 이급 시민이다. 인스턴스화한 결과가 값으로 귀결되는 클래스를 정의할 때 메소드를 유용하게 활용할 여지는 있지만 여전히
     *  메소드, 클래스는 그 자체로 값이 될 수 없다.
     *
     *  다른 언어에서 메소드를 일급값으로 사용하면 프로그래머가 활용할 수 있는 도구가 다양해지면 프로그래밍이 수월해진다는 사실이 입증되면서 자바8을 설계하면서
     *  메소드를 값으로 취급할수 있게 만들었고 이러한 메소드를 값으로 취급할 수 있는 기능은 스트림 같은 다른 자바8 API의 토대가 되었다.
     *
     *      1. 메소드 참조(Method reference)이다. 자바 8의 메소드 참조는 '::'(이 메소드를 값으로 사용하라는 의미)를 이용해서 메소드를 값으로 전달할
     *      수 있다.
     *      2. 람다: 익명 함수이다. 자바 8에서는 기명(named) 메소드를 일급값으로 취급할 뿐만 아니라 람다(또는 익명 함수)를 포함하여 함수도 값으로 취급
     *      할 수 있다. 여기서 기명 함수를 메소드 참조로 사용하면 되는데 왜 람다가 필요한지 의문을 갖을 수 있다. 물론, 메소드를 직접 정의할 수도 있지만
     *      이용할 수 있는 편리한 클래스, 메소드가 없을 경우 람다를 사용하면 더 간결하게 코드를 구현할 수 있다.
     *
     *
     *      -  코드 넘겨주기(메소드 전달)과 람다
     *  위의 두 가지를 바탕으로 어떤 코드(함수를) 다른 코드 안으로 값으로 넘겨줄 수 있다. 메소드를 전달하는 것은 유용하지만 매번 메소드를 정의하는 것은
     *  귀찮은 일이다. 람다는 이러한 귀찮음을 해소해 준다. 람다는 한 번만 사용할 메소드를 따로 구현할 필요 없이 그 자리에서 만들어서 사용할 수 있게 해준다.
     *  물론 람다가 길어진다면 가독성이 떨어지므로 메소드를 넘기는 것이 훨씬 나을 수도 있다.
     *
     *
     *      > 1.4 스트림
     *  스트림 API를 이용하면 컬렉션 API와는 다른 방식으로 데이터를 처리할 수 있다. 컬렉션에서는 반복 과정을 직접 처리해야한다. for-each 루프 등을
     *  사용해야한다. 이러한 반복을 외부 반복이라고 한다. 반면 스트림 API를 사용하면 로프를 신경 쓸 필요가 없다. 스트림 API에서는 라이브러리 내부에서
     *  모든 데이터가 처리된다. 이와 같은 반복을 내부 반복이라고 한다. 또한 컬렉션을 이용했을 때 다른 문제도 생길 수 있다. 예를 들어 많은 요소를 가진
     *  목록을 반복한다면 시간이 오래 걸릴 수 있다.
     *
     *
     *      - 멀티쓰레딩
     *  이전 자바에서는 쓰레드 API로 멀티쓰레딩 코드를 구현해서 병렬성을 사용하는 것은 쉽지 않다. 멀티쓰레딩 환경에서 각각의 쓰레드는 동시에 공유된 데이터에
     *  접근하고, 데이터를 갱신할 수 있다. 결과적으로 멀티쓰레드를 제어하지 못하면 원치 않는 결과를 초래할 수 있다. 스트림은 '컬렉션을 다루면서 발생하는 문제'
     *  와 '멀티 코어 활용 어려움'이라는 두 가지 문제를 모두 해결했다. 기존 컬렉션에서는 반복되는 패턴이 많았고 CPU를 효율적으로 사용하지 못했다.
     *  이러한 원인은 컬렉션은 '어떻게 데이터를 저장하고 접근하는지'에 초점을 뒀기 때문이고 스트림은 '데이터에 어떤 계산을 할 것인지 묘사하는 것'에 초점을
     *  뒀기 때문이다.
     *
     *      > 1.5 디폴트 메소드와 자바 모듈
     *  자바 9에서 도입된 모듈 시스템은 모듈을 정의하는 문법을 제공하므로 이를 통해서 패키지 모음을 포함하는 모듈을 정의할 수 있게 되었다. 또한, 자바 8에서
     *  는 인터페이스를 쉽게 바꿀 수 있도록 '디폴트 메소드'를 지원한다. 만약 자바에서 제공하던 인터페이스를 구현해서 사용하는 경우가 있다고 했을 때,
     *  버전이 올라감에 따라서 해당 인터페이스에 새로운 메소드를 추가한다면 개발자들은 해당 인터페이스에 추가된 메소드를 구현해야하는 난처한 상황에 빠지게 된다.
     *  이러한 문제점이 발생할 수 있기 때문에는 자바8은 구현 클래스에서 구현하지 않아도 되는 메소드를 인터페이스에 추가할 수 있게 되었다. 메소드 본문은
     *  클래스 구현이 아닌 인터페이스의 일부로 포함된다. (그래서 default 메소드이다.) 디폴트 메소드를 사용하면 기존 코드를 수정하지 않고도 인터페이스
     *  설계를 자유롭게 확장할 수 있다. 여기서 하나의 클래스에 여러 인터페이스를 구현할 수 있다는 것을 생각해보자. 거기에 인터페이스에 디폴트 메소드가 추가됐다.
     *  이는 다중 상속일까? 엄밀히는 아니지만 어느 정도 그렇다고 할 수 있다.
     *
     *      > 1.6 함수형 프로그래밍에서 가져온 다른 아이디어
     *   자바 8에서 또한 Null 참조를 피할 수 있도록 도와주는 Optional 클래스를 제공한다. Optional은 값을 갖거나 갖지 않을 수 있는 컨테이너 객체이다.
     *   또한 Optional은 값이 없는 상황을 어떻게 처리할지 명시적으로 구현하는 메소드를 포함하고 있다.
     */
}
